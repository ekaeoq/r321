{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\nimport ExpoRandom from \"./ExpoRandom\";\nfunction assertByteCount(value, methodName) {\n  if (typeof value !== 'number' || isNaN(value) || Math.floor(value) < 0 || Math.floor(value) > 1024) {\n    throw new TypeError(\"expo-random: \" + methodName + \"(\" + value + \") expected a valid number from range 0...1024\");\n  }\n}\nexport function getRandomBytes(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytes');\n  var validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      var array = new Uint8Array(validByteCount);\n      for (var i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    var base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\nexport function getRandomBytesAsync(_x) {\n  return _getRandomBytesAsync.apply(this, arguments);\n}\nfunction _getRandomBytesAsync() {\n  _getRandomBytesAsync = _asyncToGenerator(function* (byteCount) {\n    assertByteCount(byteCount, 'getRandomBytesAsync');\n    var validByteCount = Math.floor(byteCount);\n    if (ExpoRandom.getRandomBytesAsync) {\n      return yield ExpoRandom.getRandomBytesAsync(validByteCount);\n    } else if (ExpoRandom.getRandomBase64StringAsync) {\n      var base64 = yield ExpoRandom.getRandomBase64StringAsync(validByteCount);\n      return toByteArray(base64);\n    } else {\n      throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n    }\n  });\n  return _getRandomBytesAsync.apply(this, arguments);\n}","map":{"version":3,"mappings":";AAAA,SAASA,WAAW,QAAQ,WAAW;AACvC,SAASC,mBAAmB,QAAQ,mBAAmB;AAEvD,OAAOC,UAAU;AAEjB,SAASC,eAAe,CAACC,KAAU,EAAEC,UAAkB;EACrD,IACE,OAAOD,KAAK,KAAK,QAAQ,IACzBE,KAAK,CAACF,KAAK,CAAC,IACZG,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC,GAAG,CAAC,IACrBG,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC,GAAG,IAAI,EACxB;IACA,MAAM,IAAIK,SAAS,mBACDJ,UAAU,SAAID,KAAK,mDACpC;;AAEL;AAUA,OAAM,SAAUM,cAAc,CAACC,SAAiB;EAC9CR,eAAe,CAACQ,SAAS,EAAE,gBAAgB,CAAC;EAC5C,IAAMC,cAAc,GAAGL,IAAI,CAACC,KAAK,CAACG,SAAS,CAAC;EAC5C,IAAIE,OAAO,EAAE;IACX,IAAI,CAACC,MAAM,CAACC,kBAAkB,IAAID,MAAM,CAACE,aAAa,EAAE;MAEtD,IAAMC,KAAK,GAAG,IAAIC,UAAU,CAACN,cAAc,CAAC;MAC5C,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,cAAc,EAAEO,CAAC,EAAE,EAAE;QACvCF,KAAK,CAACE,CAAC,CAAC,GAAGZ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACa,MAAM,EAAE,GAAG,GAAG,CAAC;;MAE5C,OAAOH,KAAK;;;EAGhB,IAAIf,UAAU,CAACQ,cAAc,EAAE;IAC7B,OAAOR,UAAU,CAACQ,cAAc,CAACE,cAAc,CAAC;GACjD,MAAM,IAAIV,UAAU,CAACmB,qBAAqB,EAAE;IAC3C,IAAMC,MAAM,GAAGpB,UAAU,CAACmB,qBAAqB,CAACT,cAAc,CAAC;IAC/D,OAAOZ,WAAW,CAACsB,MAAM,CAAC;GAC3B,MAAM;IACL,MAAM,IAAIrB,mBAAmB,CAAC,aAAa,EAAE,gBAAgB,CAAC;;AAElE;AASA,gBAAsBsB,mBAAmB;EAAA;AAAA;AAWxC;EAAA,yCAXM,WAAmCZ,SAAiB;IACzDR,eAAe,CAACQ,SAAS,EAAE,qBAAqB,CAAC;IACjD,IAAMC,cAAc,GAAGL,IAAI,CAACC,KAAK,CAACG,SAAS,CAAC;IAC5C,IAAIT,UAAU,CAACqB,mBAAmB,EAAE;MAClC,aAAarB,UAAU,CAACqB,mBAAmB,CAACX,cAAc,CAAC;KAC5D,MAAM,IAAIV,UAAU,CAACsB,0BAA0B,EAAE;MAChD,IAAMF,MAAM,SAASpB,UAAU,CAACsB,0BAA0B,CAACZ,cAAc,CAAC;MAC1E,OAAOZ,WAAW,CAACsB,MAAM,CAAC;KAC3B,MAAM;MACL,MAAM,IAAIrB,mBAAmB,CAAC,aAAa,EAAE,qBAAqB,CAAC;;EAEvE,CAAC;EAAA;AAAA","names":["toByteArray","UnavailabilityError","ExpoRandom","assertByteCount","value","methodName","isNaN","Math","floor","TypeError","getRandomBytes","byteCount","validByteCount","__DEV__","global","nativeCallSyncHook","__REMOTEDEV__","array","Uint8Array","i","random","getRandomBase64String","base64","getRandomBytesAsync","getRandomBase64StringAsync"],"sourceRoot":"","sources":["../src/Random.ts"],"sourcesContent":["import { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoRandom from './ExpoRandom';\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-random: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * Falls back to `Math.random` during development to prevent issues with React Native Debugger.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      // remote javascript debugging is enabled\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    const base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytesAsync) {\n    return await ExpoRandom.getRandomBytesAsync(validByteCount);\n  } else if (ExpoRandom.getRandomBase64StringAsync) {\n    const base64 = await ExpoRandom.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}