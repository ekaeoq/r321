{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n  return r;\n};\nimport React from \"react\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { Circle, G, Path, Polygon, Polyline, Rect, Svg } from \"react-native-svg\";\nimport AbstractChart from \"../AbstractChart\";\nimport { LegendItem } from \"./LegendItem\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar AnimatedCircle = Animated.createAnimatedComponent(Circle);\nvar LineChart = function (_super) {\n  __extends(LineChart, _super);\n  function LineChart() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.label = React.createRef();\n    _this.state = {\n      scrollableDotHorizontalOffset: new Animated.Value(0)\n    };\n    _this.getColor = function (dataset, opacity) {\n      return (dataset.color || _this.props.chartConfig.color)(opacity);\n    };\n    _this.getStrokeWidth = function (dataset) {\n      return dataset.strokeWidth || _this.props.chartConfig.strokeWidth || 3;\n    };\n    _this.getDatas = function (data) {\n      return data.reduce(function (acc, item) {\n        return item.data ? __spreadArrays(acc, item.data) : acc;\n      }, []);\n    };\n    _this.getPropsForDots = function (x, i) {\n      var _a = _this.props,\n        getDotProps = _a.getDotProps,\n        chartConfig = _a.chartConfig;\n      if (typeof getDotProps === \"function\") {\n        return getDotProps(x, i);\n      }\n      var _b = chartConfig.propsForDots,\n        propsForDots = _b === void 0 ? {} : _b;\n      return __assign({\n        r: \"4\"\n      }, propsForDots);\n    };\n    _this.renderDots = function (_a) {\n      var data = _a.data,\n        width = _a.width,\n        height = _a.height,\n        paddingTop = _a.paddingTop,\n        paddingRight = _a.paddingRight,\n        onDataPointClick = _a.onDataPointClick;\n      var output = [];\n      var datas = _this.getDatas(data);\n      var baseHeight = _this.calcBaseHeight(datas, height);\n      var _b = _this.props,\n        getDotColor = _b.getDotColor,\n        _c = _b.hidePointsAtIndex,\n        hidePointsAtIndex = _c === void 0 ? [] : _c,\n        _d = _b.renderDotContent,\n        renderDotContent = _d === void 0 ? function () {\n          return null;\n        } : _d;\n      var xMax = _this.getXMaxValues(data);\n      data.forEach(function (dataset) {\n        if (dataset.withDots == false) return;\n        dataset.data.forEach(function (x, i) {\n          if (hidePointsAtIndex.includes(i)) {\n            return;\n          }\n          var cx = paddingRight + i * (width - paddingRight) / xMax;\n          var cy = (baseHeight - _this.calcHeight(x, datas, height)) / 4 * 3 + paddingTop;\n          var onPress = function onPress() {\n            if (!onDataPointClick || hidePointsAtIndex.includes(i)) {\n              return;\n            }\n            onDataPointClick({\n              index: i,\n              value: x,\n              dataset: dataset,\n              x: cx,\n              y: cy,\n              getColor: function getColor(opacity) {\n                return _this.getColor(dataset, opacity);\n              }\n            });\n          };\n          output.push(_jsx(Circle, _objectSpread({\n            cx: cx,\n            cy: cy,\n            fill: typeof getDotColor === \"function\" ? getDotColor(x, i) : _this.getColor(dataset, 0.9),\n            onPress: onPress\n          }, _this.getPropsForDots(x, i)), Math.random()), _jsx(Circle, {\n            cx: cx,\n            cy: cy,\n            r: \"14\",\n            fill: \"#fff\",\n            fillOpacity: 0,\n            onPress: onPress\n          }, Math.random()), renderDotContent({\n            x: cx,\n            y: cy,\n            index: i,\n            indexData: x\n          }));\n        });\n      });\n      return output;\n    };\n    _this.renderScrollableDot = function (_a) {\n      var data = _a.data,\n        width = _a.width,\n        height = _a.height,\n        paddingTop = _a.paddingTop,\n        paddingRight = _a.paddingRight,\n        scrollableDotHorizontalOffset = _a.scrollableDotHorizontalOffset,\n        scrollableDotFill = _a.scrollableDotFill,\n        scrollableDotStrokeColor = _a.scrollableDotStrokeColor,\n        scrollableDotStrokeWidth = _a.scrollableDotStrokeWidth,\n        scrollableDotRadius = _a.scrollableDotRadius,\n        scrollableInfoViewStyle = _a.scrollableInfoViewStyle,\n        scrollableInfoTextStyle = _a.scrollableInfoTextStyle,\n        _b = _a.scrollableInfoTextDecorator,\n        scrollableInfoTextDecorator = _b === void 0 ? function (x) {\n          return \"\" + x;\n        } : _b,\n        scrollableInfoSize = _a.scrollableInfoSize,\n        scrollableInfoOffset = _a.scrollableInfoOffset;\n      var output = [];\n      var datas = _this.getDatas(data);\n      var baseHeight = _this.calcBaseHeight(datas, height);\n      var vl = [];\n      var perData = width / data[0].data.length;\n      for (var index = 0; index < data[0].data.length; index++) {\n        vl.push(index * perData);\n      }\n      var lastIndex;\n      scrollableDotHorizontalOffset.addListener(function (value) {\n        var index = value.value / perData;\n        if (!lastIndex) {\n          lastIndex = index;\n        }\n        var abs = Math.floor(index);\n        var percent = index - abs;\n        abs = data[0].data.length - abs - 1;\n        if (index >= data[0].data.length - 1) {\n          _this.label.current.setNativeProps({\n            text: scrollableInfoTextDecorator(Math.floor(data[0].data[0]))\n          });\n        } else {\n          if (index > lastIndex) {\n            var base = data[0].data[abs];\n            var prev = data[0].data[abs - 1];\n            if (prev > base) {\n              var rest = prev - base;\n              _this.label.current.setNativeProps({\n                text: scrollableInfoTextDecorator(Math.floor(base + percent * rest))\n              });\n            } else {\n              var rest = base - prev;\n              _this.label.current.setNativeProps({\n                text: scrollableInfoTextDecorator(Math.floor(base - percent * rest))\n              });\n            }\n          } else {\n            var base = data[0].data[abs - 1];\n            var next = data[0].data[abs];\n            percent = 1 - percent;\n            if (next > base) {\n              var rest = next - base;\n              _this.label.current.setNativeProps({\n                text: scrollableInfoTextDecorator(Math.floor(base + percent * rest))\n              });\n            } else {\n              var rest = base - next;\n              _this.label.current.setNativeProps({\n                text: scrollableInfoTextDecorator(Math.floor(base - percent * rest))\n              });\n            }\n          }\n        }\n        lastIndex = index;\n      });\n      data.forEach(function (dataset) {\n        if (dataset.withScrollableDot == false) return;\n        var perData = width / dataset.data.length;\n        var values = [];\n        var yValues = [];\n        var xValues = [];\n        var yValuesLabel = [];\n        var xValuesLabel = [];\n        for (var index = 0; index < dataset.data.length; index++) {\n          values.push(index * perData);\n          var yval = (baseHeight - _this.calcHeight(dataset.data[dataset.data.length - index - 1], datas, height)) / 4 * 3 + paddingTop;\n          yValues.push(yval);\n          var xval = paddingRight + (dataset.data.length - index - 1) * (width - paddingRight) / dataset.data.length;\n          xValues.push(xval);\n          yValuesLabel.push(yval - (scrollableInfoSize.height + scrollableInfoOffset));\n          xValuesLabel.push(xval - scrollableInfoSize.width / 2);\n        }\n        var translateX = scrollableDotHorizontalOffset.interpolate({\n          inputRange: values,\n          outputRange: xValues,\n          extrapolate: \"clamp\"\n        });\n        var translateY = scrollableDotHorizontalOffset.interpolate({\n          inputRange: values,\n          outputRange: yValues,\n          extrapolate: \"clamp\"\n        });\n        var labelTranslateX = scrollableDotHorizontalOffset.interpolate({\n          inputRange: values,\n          outputRange: xValuesLabel,\n          extrapolate: \"clamp\"\n        });\n        var labelTranslateY = scrollableDotHorizontalOffset.interpolate({\n          inputRange: values,\n          outputRange: yValuesLabel,\n          extrapolate: \"clamp\"\n        });\n        output.push([_jsx(Animated.View, {\n          style: [scrollableInfoViewStyle, {\n            transform: [{\n              translateX: labelTranslateX\n            }, {\n              translateY: labelTranslateY\n            }],\n            width: scrollableInfoSize.width,\n            height: scrollableInfoSize.height\n          }],\n          children: _jsx(TextInput, {\n            onLayout: function onLayout() {\n              _this.label.current.setNativeProps({\n                text: scrollableInfoTextDecorator(Math.floor(data[0].data[data[0].data.length - 1]))\n              });\n            },\n            style: scrollableInfoTextStyle,\n            ref: _this.label\n          })\n        }, Math.random()), _jsx(AnimatedCircle, {\n          cx: translateX,\n          cy: translateY,\n          r: scrollableDotRadius,\n          stroke: scrollableDotStrokeColor,\n          strokeWidth: scrollableDotStrokeWidth,\n          fill: scrollableDotFill\n        }, Math.random())]);\n      });\n      return output;\n    };\n    _this.renderShadow = function (_a) {\n      var width = _a.width,\n        height = _a.height,\n        paddingRight = _a.paddingRight,\n        paddingTop = _a.paddingTop,\n        data = _a.data,\n        useColorFromDataset = _a.useColorFromDataset;\n      if (_this.props.bezier) {\n        return _this.renderBezierShadow({\n          width: width,\n          height: height,\n          paddingRight: paddingRight,\n          paddingTop: paddingTop,\n          data: data,\n          useColorFromDataset: useColorFromDataset\n        });\n      }\n      var datas = _this.getDatas(data);\n      var baseHeight = _this.calcBaseHeight(datas, height);\n      return data.map(function (dataset, index) {\n        return _jsx(Polygon, {\n          points: dataset.data.map(function (d, i) {\n            var x = paddingRight + i * (width - paddingRight) / dataset.data.length;\n            var y = (baseHeight - _this.calcHeight(d, datas, height)) / 4 * 3 + paddingTop;\n            return x + \",\" + y;\n          }).join(\" \") + (\" \" + (paddingRight + (width - paddingRight) / dataset.data.length * (dataset.data.length - 1)) + \",\" + (height / 4 * 3 + paddingTop) + \" \" + paddingRight + \",\" + (height / 4 * 3 + paddingTop)),\n          fill: \"url(#fillShadowGradientFrom\" + (useColorFromDataset ? \"_\" + index : \"\") + \")\",\n          strokeWidth: 0\n        }, index);\n      });\n    };\n    _this.renderLine = function (_a) {\n      var width = _a.width,\n        height = _a.height,\n        paddingRight = _a.paddingRight,\n        paddingTop = _a.paddingTop,\n        data = _a.data,\n        linejoinType = _a.linejoinType;\n      if (_this.props.bezier) {\n        return _this.renderBezierLine({\n          data: data,\n          width: width,\n          height: height,\n          paddingRight: paddingRight,\n          paddingTop: paddingTop\n        });\n      }\n      var output = [];\n      var datas = _this.getDatas(data);\n      var baseHeight = _this.calcBaseHeight(datas, height);\n      var xMax = _this.getXMaxValues(data);\n      var lastPoint;\n      data.forEach(function (dataset, index) {\n        var points = dataset.data.map(function (d, i) {\n          if (d === null) return lastPoint;\n          var x = i * (width - paddingRight) / xMax + paddingRight;\n          var y = (baseHeight - _this.calcHeight(d, datas, height)) / 4 * 3 + paddingTop;\n          lastPoint = x + \",\" + y;\n          return x + \",\" + y;\n        });\n        output.push(_jsx(Polyline, {\n          strokeLinejoin: linejoinType,\n          points: points.join(\" \"),\n          fill: \"none\",\n          stroke: _this.getColor(dataset, 0.2),\n          strokeWidth: _this.getStrokeWidth(dataset),\n          strokeDasharray: dataset.strokeDashArray,\n          strokeDashoffset: dataset.strokeDashOffset\n        }, index));\n      });\n      return output;\n    };\n    _this.getXMaxValues = function (data) {\n      return data.reduce(function (acc, cur) {\n        return cur.data.length > acc ? cur.data.length : acc;\n      }, 0);\n    };\n    _this.getBezierLinePoints = function (dataset, _a) {\n      var width = _a.width,\n        height = _a.height,\n        paddingRight = _a.paddingRight,\n        paddingTop = _a.paddingTop,\n        data = _a.data;\n      if (dataset.data.length === 0) {\n        return \"M0,0\";\n      }\n      var datas = _this.getDatas(data);\n      var xMax = _this.getXMaxValues(data);\n      var x = function x(i) {\n        return Math.floor(paddingRight + i * (width - paddingRight) / xMax);\n      };\n      var baseHeight = _this.calcBaseHeight(datas, height);\n      var y = function y(i) {\n        var yHeight = _this.calcHeight(dataset.data[i], datas, height);\n        return Math.floor((baseHeight - yHeight) / 4 * 3 + paddingTop);\n      };\n      return [\"M\" + x(0) + \",\" + y(0)].concat(dataset.data.slice(0, -1).map(function (_, i) {\n        var x_mid = (x(i) + x(i + 1)) / 2;\n        var y_mid = (y(i) + y(i + 1)) / 2;\n        var cp_x1 = (x_mid + x(i)) / 2;\n        var cp_x2 = (x_mid + x(i + 1)) / 2;\n        return \"Q \" + cp_x1 + \", \" + y(i) + \", \" + x_mid + \", \" + y_mid + (\" Q \" + cp_x2 + \", \" + y(i + 1) + \", \" + x(i + 1) + \", \" + y(i + 1));\n      })).join(\" \");\n    };\n    _this.renderBezierLine = function (_a) {\n      var data = _a.data,\n        width = _a.width,\n        height = _a.height,\n        paddingRight = _a.paddingRight,\n        paddingTop = _a.paddingTop;\n      return data.map(function (dataset, index) {\n        var result = _this.getBezierLinePoints(dataset, {\n          width: width,\n          height: height,\n          paddingRight: paddingRight,\n          paddingTop: paddingTop,\n          data: data\n        });\n        return _jsx(Path, {\n          d: result,\n          fill: \"none\",\n          stroke: _this.getColor(dataset, 0.2),\n          strokeWidth: _this.getStrokeWidth(dataset),\n          strokeDasharray: dataset.strokeDashArray,\n          strokeDashoffset: dataset.strokeDashOffset\n        }, index);\n      });\n    };\n    _this.renderBezierShadow = function (_a) {\n      var width = _a.width,\n        height = _a.height,\n        paddingRight = _a.paddingRight,\n        paddingTop = _a.paddingTop,\n        data = _a.data,\n        useColorFromDataset = _a.useColorFromDataset;\n      return data.map(function (dataset, index) {\n        var xMax = _this.getXMaxValues(data);\n        var d = _this.getBezierLinePoints(dataset, {\n          width: width,\n          height: height,\n          paddingRight: paddingRight,\n          paddingTop: paddingTop,\n          data: data\n        }) + (\" L\" + (paddingRight + (width - paddingRight) / xMax * (dataset.data.length - 1)) + \",\" + (height / 4 * 3 + paddingTop) + \" L\" + paddingRight + \",\" + (height / 4 * 3 + paddingTop) + \" Z\");\n        return _jsx(Path, {\n          d: d,\n          fill: \"url(#fillShadowGradientFrom\" + (useColorFromDataset ? \"_\" + index : \"\") + \")\",\n          strokeWidth: 0\n        }, index);\n      });\n    };\n    _this.renderLegend = function (width, legendOffset) {\n      var _a = _this.props.data,\n        legend = _a.legend,\n        datasets = _a.datasets;\n      var baseLegendItemX = width / (legend.length + 1);\n      return legend.map(function (legendItem, i) {\n        return _jsx(G, {\n          children: _jsx(LegendItem, {\n            index: i,\n            iconColor: _this.getColor(datasets[i], 0.9),\n            baseLegendItemX: baseLegendItemX,\n            legendText: legendItem,\n            labelProps: __assign({}, _this.getPropsForLabels()),\n            legendOffset: legendOffset\n          })\n        }, Math.random());\n      });\n    };\n    return _this;\n  }\n  LineChart.prototype.render = function () {\n    var _a = this.props,\n      width = _a.width,\n      height = _a.height,\n      data = _a.data,\n      _b = _a.withScrollableDot,\n      withScrollableDot = _b === void 0 ? false : _b,\n      _c = _a.withShadow,\n      withShadow = _c === void 0 ? true : _c,\n      _d = _a.withDots,\n      withDots = _d === void 0 ? true : _d,\n      _e = _a.withInnerLines,\n      withInnerLines = _e === void 0 ? true : _e,\n      _f = _a.withOuterLines,\n      withOuterLines = _f === void 0 ? true : _f,\n      _g = _a.withHorizontalLines,\n      withHorizontalLines = _g === void 0 ? true : _g,\n      _h = _a.withVerticalLines,\n      withVerticalLines = _h === void 0 ? true : _h,\n      _j = _a.withHorizontalLabels,\n      withHorizontalLabels = _j === void 0 ? true : _j,\n      _k = _a.withVerticalLabels,\n      withVerticalLabels = _k === void 0 ? true : _k,\n      _l = _a.style,\n      style = _l === void 0 ? {} : _l,\n      decorator = _a.decorator,\n      onDataPointClick = _a.onDataPointClick,\n      _m = _a.verticalLabelRotation,\n      verticalLabelRotation = _m === void 0 ? 0 : _m,\n      _o = _a.horizontalLabelRotation,\n      horizontalLabelRotation = _o === void 0 ? 0 : _o,\n      _p = _a.formatYLabel,\n      formatYLabel = _p === void 0 ? function (yLabel) {\n        return yLabel;\n      } : _p,\n      _q = _a.formatXLabel,\n      formatXLabel = _q === void 0 ? function (xLabel) {\n        return xLabel;\n      } : _q,\n      segments = _a.segments,\n      _r = _a.transparent,\n      transparent = _r === void 0 ? false : _r,\n      chartConfig = _a.chartConfig;\n    var scrollableDotHorizontalOffset = this.state.scrollableDotHorizontalOffset;\n    var _s = data.labels,\n      labels = _s === void 0 ? [] : _s;\n    var _t = style.borderRadius,\n      borderRadius = _t === void 0 ? 0 : _t,\n      _u = style.paddingTop,\n      paddingTop = _u === void 0 ? 16 : _u,\n      _v = style.paddingRight,\n      paddingRight = _v === void 0 ? 64 : _v,\n      _w = style.margin,\n      margin = _w === void 0 ? 0 : _w,\n      _x = style.marginRight,\n      marginRight = _x === void 0 ? 0 : _x,\n      _y = style.paddingBottom,\n      paddingBottom = _y === void 0 ? 0 : _y;\n    var config = {\n      width: width,\n      height: height,\n      verticalLabelRotation: verticalLabelRotation,\n      horizontalLabelRotation: horizontalLabelRotation\n    };\n    var datas = this.getDatas(data.datasets);\n    var count = Math.min.apply(Math, datas) === Math.max.apply(Math, datas) ? 1 : 4;\n    if (segments) {\n      count = segments;\n    }\n    var legendOffset = this.props.data.legend ? height * 0.15 : 0;\n    return _jsxs(View, {\n      style: style,\n      children: [_jsxs(Svg, {\n        height: height + paddingBottom + legendOffset,\n        width: width - margin * 2 - marginRight,\n        children: [_jsx(Rect, {\n          width: \"100%\",\n          height: height + legendOffset,\n          rx: borderRadius,\n          ry: borderRadius,\n          fill: \"url(#backgroundGradient)\",\n          fillOpacity: transparent ? 0 : 1\n        }), this.props.data.legend && this.renderLegend(config.width, legendOffset), _jsxs(G, {\n          x: \"0\",\n          y: legendOffset,\n          children: [this.renderDefs(__assign(__assign(__assign({}, config), chartConfig), {\n            data: data.datasets\n          })), _jsx(G, {\n            children: withHorizontalLines && (withInnerLines ? this.renderHorizontalLines(__assign(__assign({}, config), {\n              count: count,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight\n            })) : withOuterLines ? this.renderHorizontalLine(__assign(__assign({}, config), {\n              paddingTop: paddingTop,\n              paddingRight: paddingRight\n            })) : null)\n          }), _jsx(G, {\n            children: withHorizontalLabels && this.renderHorizontalLabels(__assign(__assign({}, config), {\n              count: count,\n              data: datas,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight,\n              formatYLabel: formatYLabel,\n              decimalPlaces: chartConfig.decimalPlaces\n            }))\n          }), _jsx(G, {\n            children: withVerticalLines && (withInnerLines ? this.renderVerticalLines(__assign(__assign({}, config), {\n              data: data.datasets[0].data,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight\n            })) : withOuterLines ? this.renderVerticalLine(__assign(__assign({}, config), {\n              paddingTop: paddingTop,\n              paddingRight: paddingRight\n            })) : null)\n          }), _jsx(G, {\n            children: withVerticalLabels && this.renderVerticalLabels(__assign(__assign({}, config), {\n              labels: labels,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight,\n              formatXLabel: formatXLabel\n            }))\n          }), _jsx(G, {\n            children: this.renderLine(__assign(__assign(__assign({}, config), chartConfig), {\n              paddingRight: paddingRight,\n              paddingTop: paddingTop,\n              data: data.datasets\n            }))\n          }), _jsx(G, {\n            children: withShadow && this.renderShadow(__assign(__assign({}, config), {\n              data: data.datasets,\n              paddingRight: paddingRight,\n              paddingTop: paddingTop,\n              useColorFromDataset: chartConfig.useShadowColorFromDataset\n            }))\n          }), _jsx(G, {\n            children: withDots && this.renderDots(__assign(__assign({}, config), {\n              data: data.datasets,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight,\n              onDataPointClick: onDataPointClick\n            }))\n          }), _jsx(G, {\n            children: withScrollableDot && this.renderScrollableDot(__assign(__assign(__assign({}, config), chartConfig), {\n              data: data.datasets,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight,\n              onDataPointClick: onDataPointClick,\n              scrollableDotHorizontalOffset: scrollableDotHorizontalOffset\n            }))\n          }), _jsx(G, {\n            children: decorator && decorator(__assign(__assign({}, config), {\n              data: data.datasets,\n              paddingTop: paddingTop,\n              paddingRight: paddingRight\n            }))\n          })]\n        })]\n      }), withScrollableDot && _jsx(ScrollView, {\n        style: StyleSheet.absoluteFill,\n        contentContainerStyle: {\n          width: width * 2\n        },\n        showsHorizontalScrollIndicator: false,\n        scrollEventThrottle: 16,\n        onScroll: Animated.event([{\n          nativeEvent: {\n            contentOffset: {\n              x: scrollableDotHorizontalOffset\n            }\n          }\n        }], {\n          useNativeDriver: false\n        }),\n        horizontal: true,\n        bounces: false\n      })]\n    });\n  };\n  return LineChart;\n}(AbstractChart);\nexport default LineChart;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAoB,MAAM,OAAO;AAAC;AAAA;AAAA;AAAA;AAAA;AASzC,SACEC,MAAM,EACNC,CAAC,EACDC,IAAI,EACJC,OAAO,EACPC,QAAQ,EACRC,IAAI,EACJC,GAAG,QACE,kBAAkB;AAEzB,OAAOC,aAGN;AAED,SAASC,UAAU;AAAuB;AAAA;AAE1C,IAAIC,cAAc,GAAGC,QAAQ,CAACC,uBAAuB,CAACX,MAAM,CAAC;AAoM7D;EAAwBY;EAAxB;IAAA;IACEC,WAAK,GAAGd,KAAK,CAACe,SAAS,EAAa;IAEpCD,WAAK,GAAG;MACNE,6BAA6B,EAAE,IAAIL,QAAQ,CAACM,KAAK,CAAC,CAAC;KACpD;IAEDH,cAAQ,GAAG,UAACI,OAAgB,EAAEC,OAAe;MAC3C,OAAO,CAACD,OAAO,CAACE,KAAK,IAAIN,KAAI,CAACO,KAAK,CAACC,WAAW,CAACF,KAAK,EAAED,OAAO,CAAC;IACjE,CAAC;IAEDL,oBAAc,GAAG,UAACI,OAAgB;MAChC,OAAOA,OAAO,CAACK,WAAW,IAAIT,KAAI,CAACO,KAAK,CAACC,WAAW,CAACC,WAAW,IAAI,CAAC;IACvE,CAAC;IAEDT,cAAQ,GAAG,UAACU,IAAe;MACzB,OAAOA,IAAI,CAACC,MAAM,CAChB,UAACC,GAAG,EAAEC,IAAI;QAAK,OAACA,IAAI,CAACH,IAAI,GAAEI,eAAKF,GAAG,EAAKC,IAAI,CAACH,IAAI,IAAIE,GAAG;MAAzC,CAA0C,EACzD,EAAE,CACH;IACH,CAAC;IAEDZ,qBAAe,GAAG,UAACe,CAAM,EAAEC,CAAS;MAC5B,SAA+BhB,KAAI,CAACO,KAAK;QAAvCU,WAAW;QAAET,WAAW,iBAAe;MAE/C,IAAI,OAAOS,WAAW,KAAK,UAAU,EAAE;QACrC,OAAOA,WAAW,CAACF,CAAC,EAAEC,CAAC,CAAC;;MAGlB,SAAsBR,WAAW,aAAhB;QAAjBU,YAAY,mBAAG,EAAE;MAEzB;QAASC,CAAC,EAAE;MAAG,GAAKD,YAAY;IAClC,CAAC;IAEDlB,gBAAU,GAAG,UAACoB,EAYb;UAXCV,IAAI;QACJW,KAAK;QACLC,MAAM;QACNC,UAAU;QACVC,YAAY;QACZC,gBAAgB;MAOhB,IAAMC,MAAM,GAAgB,EAAE;MAC9B,IAAMC,KAAK,GAAG3B,KAAI,CAAC4B,QAAQ,CAAClB,IAAI,CAAC;MACjC,IAAMmB,UAAU,GAAG7B,KAAI,CAAC8B,cAAc,CAACH,KAAK,EAAEL,MAAM,CAAC;MAE/C,SAMFtB,KAAI,CAACO,KAAK;QALZwB,WAAW;QACXC,yBAAsB;QAAtBC,iBAAiB,mBAAG,EAAE;QACtBC,wBAEC;QAFDC,gBAAgB,mBAAG;UACjB,OAAO,IAAI;QACb,CAAC,KACW;MACd,IAAMC,IAAI,GAAGpC,KAAI,CAACqC,aAAa,CAAC3B,IAAI,CAAC;MACrCA,IAAI,CAAC4B,OAAO,CAAC,iBAAO;QAClB,IAAIlC,OAAO,CAACmC,QAAQ,IAAI,KAAK,EAAE;QAE/BnC,OAAO,CAACM,IAAI,CAAC4B,OAAO,CAAC,UAACvB,CAAC,EAAEC,CAAC;UACxB,IAAIiB,iBAAiB,CAACO,QAAQ,CAACxB,CAAC,CAAC,EAAE;YACjC;;UAGF,IAAMyB,EAAE,GAAGjB,YAAY,GAAIR,CAAC,IAAIK,KAAK,GAAGG,YAAY,CAAC,GAAIY,IAAI;UAE7D,IAAMM,EAAE,GACL,CAACb,UAAU,GAAG7B,KAAI,CAAC2C,UAAU,CAAC5B,CAAC,EAAEY,KAAK,EAAEL,MAAM,CAAC,IAAI,CAAC,GAAI,CAAC,GAC1DC,UAAU;UAEZ,IAAMqB,OAAO,GAAG,SAAVA,OAAO,GAAG;YACd,IAAI,CAACnB,gBAAgB,IAAIQ,iBAAiB,CAACO,QAAQ,CAACxB,CAAC,CAAC,EAAE;cACtD;;YAGFS,gBAAgB,CAAC;cACfoB,KAAK,EAAE7B,CAAC;cACR8B,KAAK,EAAE/B,CAAC;cACRX,OAAO;cACPW,CAAC,EAAE0B,EAAE;cACLM,CAAC,EAAEL,EAAE;cACLM,QAAQ,EAAE,yBAAO;gBAAI,YAAI,CAACA,QAAQ,CAAC5C,OAAO,EAAEC,OAAO,CAAC;cAA/B;aACtB,CAAC;UACJ,CAAC;UAEDqB,MAAM,CAACuB,IAAI,CACT,KAAC,MAAM;YAEL,EAAE,EAAER,EAAG;YACP,EAAE,EAAEC,EAAG;YACP,IAAI,EACF,OAAOX,WAAW,KAAK,UAAU,GAC7BA,WAAW,CAAChB,CAAC,EAAEC,CAAC,CAAC,GACjBhB,KAAI,CAACgD,QAAQ,CAAC5C,OAAO,EAAE,GAAG,CAC/B;YACD,OAAO,EAAEwC;UAAQ,GACb5C,KAAI,CAACkD,eAAe,CAACnC,CAAC,EAAEC,CAAC,CAAC,GATzBmC,IAAI,CAACC,MAAM,EAAE,CAUlB,EACF,KAAC,MAAM;YAEL,EAAE,EAAEX,EAAG;YACP,EAAE,EAAEC,EAAG;YACP,CAAC,EAAC,IAAI;YACN,IAAI,EAAC,MAAM;YACX,WAAW,EAAE,CAAE;YACf,OAAO,EAAEE;UAAQ,GANZO,IAAI,CAACC,MAAM,EAAE,CAOlB,EACFjB,gBAAgB,CAAC;YAAEpB,CAAC,EAAE0B,EAAE;YAAEM,CAAC,EAAEL,EAAE;YAAEG,KAAK,EAAE7B,CAAC;YAAEqC,SAAS,EAAEtC;UAAC,CAAE,CAAC,CAC3D;QACH,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,OAAOW,MAAM;IACf,CAAC;IAED1B,yBAAmB,GAAG,UAACoB,EAmBtB;UAlBCV,IAAI;QACJW,KAAK;QACLC,MAAM;QACNC,UAAU;QACVC,YAAY;QACZtB,6BAA6B;QAC7BoD,iBAAiB;QACjBC,wBAAwB;QACxBC,wBAAwB;QACxBC,mBAAmB;QACnBC,uBAAuB;QACvBC,uBAAuB;QACvBC,mCAAyC;QAAzCC,2BAA2B,mBAAG,WAAC;UAAI,YAAG9C,CAAG;QAAN,CAAM;QACzC+C,kBAAkB;QAClBC,oBAAoB;MAKpB,IAAMrC,MAAM,GAAG,EAAE;MACjB,IAAMC,KAAK,GAAG3B,KAAI,CAAC4B,QAAQ,CAAClB,IAAI,CAAC;MACjC,IAAMmB,UAAU,GAAG7B,KAAI,CAAC8B,cAAc,CAACH,KAAK,EAAEL,MAAM,CAAC;MAErD,IAAI0C,EAAE,GAAa,EAAE;MAErB,IAAMC,OAAO,GAAG5C,KAAK,GAAGX,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAACwD,MAAM;MAC3C,KAAK,IAAIrB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGnC,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAACwD,MAAM,EAAErB,KAAK,EAAE,EAAE;QACxDmB,EAAE,CAACf,IAAI,CAACJ,KAAK,GAAGoB,OAAO,CAAC;;MAE1B,IAAIE,SAAiB;MAErBjE,6BAA6B,CAACkE,WAAW,CAAC,eAAK;QAC7C,IAAMvB,KAAK,GAAGC,KAAK,CAACA,KAAK,GAAGmB,OAAO;QACnC,IAAI,CAACE,SAAS,EAAE;UACdA,SAAS,GAAGtB,KAAK;;QAGnB,IAAIwB,GAAG,GAAGlB,IAAI,CAACmB,KAAK,CAACzB,KAAK,CAAC;QAC3B,IAAI0B,OAAO,GAAG1B,KAAK,GAAGwB,GAAG;QACzBA,GAAG,GAAG3D,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAACwD,MAAM,GAAGG,GAAG,GAAG,CAAC;QAEnC,IAAIxB,KAAK,IAAInC,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAACwD,MAAM,GAAG,CAAC,EAAE;UACpClE,KAAI,CAACwE,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC;YAChCC,IAAI,EAAEd,2BAA2B,CAACV,IAAI,CAACmB,KAAK,CAAC5D,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAAC,CAAC,CAAC,CAAC;WAC9D,CAAC;SACH,MAAM;UACL,IAAImC,KAAK,GAAGsB,SAAS,EAAE;YAGrB,IAAMS,IAAI,GAAGlE,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAAC2D,GAAG,CAAC;YAC9B,IAAMQ,IAAI,GAAGnE,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAAC2D,GAAG,GAAG,CAAC,CAAC;YAClC,IAAIQ,IAAI,GAAGD,IAAI,EAAE;cACf,IAAIE,IAAI,GAAGD,IAAI,GAAGD,IAAI;cACtB5E,KAAI,CAACwE,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC;gBAChCC,IAAI,EAAEd,2BAA2B,CAC/BV,IAAI,CAACmB,KAAK,CAACM,IAAI,GAAGL,OAAO,GAAGO,IAAI,CAAC;eAEpC,CAAC;aACH,MAAM;cACL,IAAIA,IAAI,GAAGF,IAAI,GAAGC,IAAI;cACtB7E,KAAI,CAACwE,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC;gBAChCC,IAAI,EAAEd,2BAA2B,CAC/BV,IAAI,CAACmB,KAAK,CAACM,IAAI,GAAGL,OAAO,GAAGO,IAAI,CAAC;eAEpC,CAAC;;WAEL,MAAM;YAGL,IAAMF,IAAI,GAAGlE,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAAC2D,GAAG,GAAG,CAAC,CAAC;YAClC,IAAMU,IAAI,GAAGrE,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAAC2D,GAAG,CAAC;YAC9BE,OAAO,GAAG,CAAC,GAAGA,OAAO;YACrB,IAAIQ,IAAI,GAAGH,IAAI,EAAE;cACf,IAAIE,IAAI,GAAGC,IAAI,GAAGH,IAAI;cACtB5E,KAAI,CAACwE,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC;gBAChCC,IAAI,EAAEd,2BAA2B,CAC/BV,IAAI,CAACmB,KAAK,CAACM,IAAI,GAAGL,OAAO,GAAGO,IAAI,CAAC;eAEpC,CAAC;aACH,MAAM;cACL,IAAIA,IAAI,GAAGF,IAAI,GAAGG,IAAI;cACtB/E,KAAI,CAACwE,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC;gBAChCC,IAAI,EAAEd,2BAA2B,CAC/BV,IAAI,CAACmB,KAAK,CAACM,IAAI,GAAGL,OAAO,GAAGO,IAAI,CAAC;eAEpC,CAAC;;;;QAIRX,SAAS,GAAGtB,KAAK;MACnB,CAAC,CAAC;MAEFnC,IAAI,CAAC4B,OAAO,CAAC,iBAAO;QAClB,IAAIlC,OAAO,CAAC4E,iBAAiB,IAAI,KAAK,EAAE;QAExC,IAAMf,OAAO,GAAG5C,KAAK,GAAGjB,OAAO,CAACM,IAAI,CAACwD,MAAM;QAC3C,IAAIe,MAAM,GAAG,EAAE;QACf,IAAIC,OAAO,GAAG,EAAE;QAChB,IAAIC,OAAO,GAAG,EAAE;QAEhB,IAAIC,YAAY,GAAG,EAAE;QACrB,IAAIC,YAAY,GAAG,EAAE;QAErB,KAAK,IAAIxC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGzC,OAAO,CAACM,IAAI,CAACwD,MAAM,EAAErB,KAAK,EAAE,EAAE;UACxDoC,MAAM,CAAChC,IAAI,CAACJ,KAAK,GAAGoB,OAAO,CAAC;UAC5B,IAAMqB,IAAI,GACP,CAACzD,UAAU,GACV7B,KAAI,CAAC2C,UAAU,CACbvC,OAAO,CAACM,IAAI,CAACN,OAAO,CAACM,IAAI,CAACwD,MAAM,GAAGrB,KAAK,GAAG,CAAC,CAAC,EAC7ClB,KAAK,EACLL,MAAM,CACP,IACD,CAAC,GACD,CAAC,GACHC,UAAU;UACZ2D,OAAO,CAACjC,IAAI,CAACqC,IAAI,CAAC;UAClB,IAAMC,IAAI,GACR/D,YAAY,GACX,CAACpB,OAAO,CAACM,IAAI,CAACwD,MAAM,GAAGrB,KAAK,GAAG,CAAC,KAAKxB,KAAK,GAAGG,YAAY,CAAC,GACzDpB,OAAO,CAACM,IAAI,CAACwD,MAAM;UACvBiB,OAAO,CAAClC,IAAI,CAACsC,IAAI,CAAC;UAElBH,YAAY,CAACnC,IAAI,CACfqC,IAAI,IAAIxB,kBAAkB,CAACxC,MAAM,GAAGyC,oBAAoB,CAAC,CAC1D;UACDsB,YAAY,CAACpC,IAAI,CAACsC,IAAI,GAAGzB,kBAAkB,CAACzC,KAAK,GAAG,CAAC,CAAC;;QAGxD,IAAMmE,UAAU,GAAGtF,6BAA6B,CAACuF,WAAW,CAAC;UAC3DC,UAAU,EAAET,MAAM;UAClBU,WAAW,EAAER,OAAO;UACpBS,WAAW,EAAE;SACd,CAAC;QAEF,IAAMC,UAAU,GAAG3F,6BAA6B,CAACuF,WAAW,CAAC;UAC3DC,UAAU,EAAET,MAAM;UAClBU,WAAW,EAAET,OAAO;UACpBU,WAAW,EAAE;SACd,CAAC;QAEF,IAAME,eAAe,GAAG5F,6BAA6B,CAACuF,WAAW,CAAC;UAChEC,UAAU,EAAET,MAAM;UAClBU,WAAW,EAAEN,YAAY;UACzBO,WAAW,EAAE;SACd,CAAC;QAEF,IAAMG,eAAe,GAAG7F,6BAA6B,CAACuF,WAAW,CAAC;UAChEC,UAAU,EAAET,MAAM;UAClBU,WAAW,EAAEP,YAAY;UACzBQ,WAAW,EAAE;SACd,CAAC;QAEFlE,MAAM,CAACuB,IAAI,CAAC,CACV,KAAC,QAAQ,CAAC,IAAI;UAEZ,KAAK,EAAE,CACLS,uBAAuB,EACvB;YACEsC,SAAS,EAAE,CACT;cAAER,UAAU,EAAEM;YAAe,CAAE,EAC/B;cAAED,UAAU,EAAEE;YAAe,CAAE,CAChC;YACD1E,KAAK,EAAEyC,kBAAkB,CAACzC,KAAK;YAC/BC,MAAM,EAAEwC,kBAAkB,CAACxC;WAC5B,CACD;UAAA,UAEF,KAAC,SAAS;YACR,QAAQ,EAAE;cACRtB,KAAI,CAACwE,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC;gBAChCC,IAAI,EAAEd,2BAA2B,CAC/BV,IAAI,CAACmB,KAAK,CAAC5D,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAACA,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,CAACwD,MAAM,GAAG,CAAC,CAAC,CAAC;eAEpD,CAAC;YACJ,CAAE;YACF,KAAK,EAAEP,uBAAwB;YAC/B,GAAG,EAAE3D,KAAI,CAACwE;UAAM;QAEpB,GAxBOrB,IAAI,CAACC,MAAM,EAAE,CAwBJ,EAChB,KAAC,cAAc;UAEb,EAAE,EAAEoC,UAAW;UACf,EAAE,EAAEK,UAAW;UACf,CAAC,EAAEpC,mBAAoB;UACvB,MAAM,EAAEF,wBAAyB;UACjC,WAAW,EAAEC,wBAAyB;UACtC,IAAI,EAAEF;QAAkB,GANnBH,IAAI,CAACC,MAAM,EAAE,CAOlB,CACH,CAAC;MACJ,CAAC,CAAC;MAEF,OAAO1B,MAAM;IACf,CAAC;IAED1B,kBAAY,GAAG,UAACoB,EAYf;UAXCC,KAAK;QACLC,MAAM;QACNE,YAAY;QACZD,UAAU;QACVb,IAAI;QACJuF,mBAAmB;MAOnB,IAAIjG,KAAI,CAACO,KAAK,CAAC2F,MAAM,EAAE;QACrB,OAAOlG,KAAI,CAACmG,kBAAkB,CAAC;UAC7B9E,KAAK;UACLC,MAAM;UACNE,YAAY;UACZD,UAAU;UACVb,IAAI;UACJuF,mBAAmB;SACpB,CAAC;;MAGJ,IAAMtE,KAAK,GAAG3B,KAAI,CAAC4B,QAAQ,CAAClB,IAAI,CAAC;MACjC,IAAMmB,UAAU,GAAG7B,KAAI,CAAC8B,cAAc,CAACH,KAAK,EAAEL,MAAM,CAAC;MAErD,OAAOZ,IAAI,CAAC0F,GAAG,CAAC,UAAChG,OAAO,EAAEyC,KAAK;QAC7B,OACE,KAAC,OAAO;UAEN,MAAM,EACJzC,OAAO,CAACM,IAAI,CACT0F,GAAG,CAAC,UAACC,CAAC,EAAErF,CAAC;YACR,IAAMD,CAAC,GACLS,YAAY,GACXR,CAAC,IAAIK,KAAK,GAAGG,YAAY,CAAC,GAAIpB,OAAO,CAACM,IAAI,CAACwD,MAAM;YAEpD,IAAMnB,CAAC,GACJ,CAAClB,UAAU,GAAG7B,KAAI,CAAC2C,UAAU,CAAC0D,CAAC,EAAE1E,KAAK,EAAEL,MAAM,CAAC,IAAI,CAAC,GAAI,CAAC,GAC1DC,UAAU;YAEZ,OAAUR,CAAC,SAAIgC,CAAG;UACpB,CAAC,CAAC,CACDuD,IAAI,CAAC,GAAG,CAAC,IACZ,OAAI9E,YAAY,GACb,CAACH,KAAK,GAAGG,YAAY,IAAIpB,OAAO,CAACM,IAAI,CAACwD,MAAM,IAC1C9D,OAAO,CAACM,IAAI,CAACwD,MAAM,GAAG,CAAC,CAAC,WAAK5C,MAAM,GAAG,CAAC,GAAI,CAAC,GAC/CC,UAAU,UAAIC,YAAY,UAAKF,MAAM,GAAG,CAAC,GAAI,CAAC,GAAGC,UAAU,CAAE,CAChE;UACD,IAAI,EAAE,iCACJ0E,mBAAmB,GAAG,MAAIpD,KAAO,GAAG,EAAE,OACpC;UACJ,WAAW,EAAE;QAAE,GAvBVA,KAAK,CAwBV;MAEN,CAAC,CAAC;IACJ,CAAC;IAED7C,gBAAU,GAAG,UAACoB,EAUb;UATCC,KAAK;QACLC,MAAM;QACNE,YAAY;QACZD,UAAU;QACVb,IAAI;QACJ6F,YAAY;MAKZ,IAAIvG,KAAI,CAACO,KAAK,CAAC2F,MAAM,EAAE;QACrB,OAAOlG,KAAI,CAACwG,gBAAgB,CAAC;UAC3B9F,IAAI;UACJW,KAAK;UACLC,MAAM;UACNE,YAAY;UACZD,UAAU;SACX,CAAC;;MAGJ,IAAMG,MAAM,GAAG,EAAE;MACjB,IAAMC,KAAK,GAAG3B,KAAI,CAAC4B,QAAQ,CAAClB,IAAI,CAAC;MACjC,IAAMmB,UAAU,GAAG7B,KAAI,CAAC8B,cAAc,CAACH,KAAK,EAAEL,MAAM,CAAC;MACrD,IAAMc,IAAI,GAAGpC,KAAI,CAACqC,aAAa,CAAC3B,IAAI,CAAC;MAErC,IAAI+F,SAAiB;MAErB/F,IAAI,CAAC4B,OAAO,CAAC,UAAClC,OAAO,EAAEyC,KAAK;QAC1B,IAAM6D,MAAM,GAAGtG,OAAO,CAACM,IAAI,CAAC0F,GAAG,CAAC,UAACC,CAAC,EAAErF,CAAC;UACnC,IAAIqF,CAAC,KAAK,IAAI,EAAE,OAAOI,SAAS;UAChC,IAAM1F,CAAC,GAAIC,CAAC,IAAIK,KAAK,GAAGG,YAAY,CAAC,GAAIY,IAAI,GAAGZ,YAAY;UAC5D,IAAMuB,CAAC,GACJ,CAAClB,UAAU,GAAG7B,KAAI,CAAC2C,UAAU,CAAC0D,CAAC,EAAE1E,KAAK,EAAEL,MAAM,CAAC,IAAI,CAAC,GAAI,CAAC,GAC1DC,UAAU;UACZkF,SAAS,GAAM1F,CAAC,SAAIgC,CAAG;UACvB,OAAUhC,CAAC,SAAIgC,CAAG;QACpB,CAAC,CAAC;QAEFrB,MAAM,CAACuB,IAAI,CACT,KAAC,QAAQ;UAEP,cAAc,EAAEsD,YAAa;UAC7B,MAAM,EAAEG,MAAM,CAACJ,IAAI,CAAC,GAAG,CAAE;UACzB,IAAI,EAAC,MAAM;UACX,MAAM,EAAEtG,KAAI,CAACgD,QAAQ,CAAC5C,OAAO,EAAE,GAAG,CAAE;UACpC,WAAW,EAAEJ,KAAI,CAAC2G,cAAc,CAACvG,OAAO,CAAE;UAC1C,eAAe,EAAEA,OAAO,CAACwG,eAAgB;UACzC,gBAAgB,EAAExG,OAAO,CAACyG;QAAiB,GAPtChE,KAAK,CAQV,CACH;MACH,CAAC,CAAC;MAEF,OAAOnB,MAAM;IACf,CAAC;IAED1B,mBAAa,GAAG,UAACU,IAAe;MAC9B,OAAOA,IAAI,CAACC,MAAM,CAAC,UAACC,GAAG,EAAEkG,GAAG;QAC1B,OAAOA,GAAG,CAACpG,IAAI,CAACwD,MAAM,GAAGtD,GAAG,GAAGkG,GAAG,CAACpG,IAAI,CAACwD,MAAM,GAAGtD,GAAG;MACtD,CAAC,EAAE,CAAC,CAAC;IACP,CAAC;IAEDZ,yBAAmB,GAAG,UACpBI,OAAgB,EAChBgB,EASC;UARCC,KAAK;QACLC,MAAM;QACNE,YAAY;QACZD,UAAU;QACVb,IAAI;MAMN,IAAIN,OAAO,CAACM,IAAI,CAACwD,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO,MAAM;;MAGf,IAAMvC,KAAK,GAAG3B,KAAI,CAAC4B,QAAQ,CAAClB,IAAI,CAAC;MACjC,IAAM0B,IAAI,GAAGpC,KAAI,CAACqC,aAAa,CAAC3B,IAAI,CAAC;MAErC,IAAMK,CAAC,GAAG,SAAJA,CAAC,CAAIC,CAAS;QAClB,WAAI,CAACsD,KAAK,CAAC9C,YAAY,GAAIR,CAAC,IAAIK,KAAK,GAAGG,YAAY,CAAC,GAAIY,IAAI,CAAC;MAA9D,CAA8D;MAEhE,IAAMP,UAAU,GAAG7B,KAAI,CAAC8B,cAAc,CAACH,KAAK,EAAEL,MAAM,CAAC;MAErD,IAAMyB,CAAC,GAAG,SAAJA,CAAC,CAAI/B,CAAS;QAClB,IAAM+F,OAAO,GAAG/G,KAAI,CAAC2C,UAAU,CAACvC,OAAO,CAACM,IAAI,CAACM,CAAC,CAAC,EAAEW,KAAK,EAAEL,MAAM,CAAC;QAE/D,OAAO6B,IAAI,CAACmB,KAAK,CAAE,CAACzC,UAAU,GAAGkF,OAAO,IAAI,CAAC,GAAI,CAAC,GAAGxF,UAAU,CAAC;MAClE,CAAC;MAED,OAAO,CAAC,MAAIR,CAAC,CAAC,CAAC,CAAC,SAAIgC,CAAC,CAAC,CAAC,CAAG,CAAC,CACxBiE,MAAM,CACL5G,OAAO,CAACM,IAAI,CAACuG,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACb,GAAG,CAAC,UAACc,CAAC,EAAElG,CAAC;QACjC,IAAMmG,KAAK,GAAG,CAACpG,CAAC,CAACC,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;QACnC,IAAMoG,KAAK,GAAG,CAACrE,CAAC,CAAC/B,CAAC,CAAC,GAAG+B,CAAC,CAAC/B,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;QACnC,IAAMqG,KAAK,GAAG,CAACF,KAAK,GAAGpG,CAAC,CAACC,CAAC,CAAC,IAAI,CAAC;QAChC,IAAMsG,KAAK,GAAG,CAACH,KAAK,GAAGpG,CAAC,CAACC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;QACpC,OACE,OAAKqG,KAAK,UAAKtE,CAAC,CAAC/B,CAAC,CAAC,UAAKmG,KAAK,UAAKC,KAAO,IACzC,QAAME,KAAK,UAAKvE,CAAC,CAAC/B,CAAC,GAAG,CAAC,CAAC,UAAKD,CAAC,CAACC,CAAC,GAAG,CAAC,CAAC,UAAK+B,CAAC,CAAC/B,CAAC,GAAG,CAAC,CAAG;MAExD,CAAC,CAAC,CACH,CACAsF,IAAI,CAAC,GAAG,CAAC;IACd,CAAC;IAEDtG,sBAAgB,GAAG,UAACoB,EASnB;UARCV,IAAI;QACJW,KAAK;QACLC,MAAM;QACNE,YAAY;QACZD,UAAU;MAKV,OAAOb,IAAI,CAAC0F,GAAG,CAAC,UAAChG,OAAO,EAAEyC,KAAK;QAC7B,IAAM0E,MAAM,GAAGvH,KAAI,CAACwH,mBAAmB,CAACpH,OAAO,EAAE;UAC/CiB,KAAK;UACLC,MAAM;UACNE,YAAY;UACZD,UAAU;UACVb,IAAI;SACL,CAAC;QAEF,OACE,KAAC,IAAI;UAEH,CAAC,EAAE6G,MAAO;UACV,IAAI,EAAC,MAAM;UACX,MAAM,EAAEvH,KAAI,CAACgD,QAAQ,CAAC5C,OAAO,EAAE,GAAG,CAAE;UACpC,WAAW,EAAEJ,KAAI,CAAC2G,cAAc,CAACvG,OAAO,CAAE;UAC1C,eAAe,EAAEA,OAAO,CAACwG,eAAgB;UACzC,gBAAgB,EAAExG,OAAO,CAACyG;QAAiB,GANtChE,KAAK,CAOV;MAEN,CAAC,CAAC;IACJ,CAAC;IAED7C,wBAAkB,GAAG,UAACoB,EAYrB;UAXCC,KAAK;QACLC,MAAM;QACNE,YAAY;QACZD,UAAU;QACVb,IAAI;QACJuF,mBAAmB;MAOnB,WAAI,CAACG,GAAG,CAAC,UAAChG,OAAO,EAAEyC,KAAK;QACtB,IAAMT,IAAI,GAAGpC,KAAI,CAACqC,aAAa,CAAC3B,IAAI,CAAC;QACrC,IAAM2F,CAAC,GACLrG,KAAI,CAACwH,mBAAmB,CAACpH,OAAO,EAAE;UAChCiB,KAAK;UACLC,MAAM;UACNE,YAAY;UACZD,UAAU;UACVb,IAAI;SACL,CAAC,IACF,QAAKc,YAAY,GACd,CAACH,KAAK,GAAGG,YAAY,IAAIY,IAAI,IAC3BhC,OAAO,CAACM,IAAI,CAACwD,MAAM,GAAG,CAAC,CAAC,WAAK5C,MAAM,GAAG,CAAC,GAAI,CAAC,GAC/CC,UAAU,WAAKC,YAAY,UAAKF,MAAM,GAAG,CAAC,GAAI,CAAC,GAAGC,UAAU,QAAI;QAEpE,OACE,KAAC,IAAI;UAEH,CAAC,EAAE8E,CAAE;UACL,IAAI,EAAE,iCACJJ,mBAAmB,GAAG,MAAIpD,KAAO,GAAG,EAAE,OACpC;UACJ,WAAW,EAAE;QAAE,GALVA,KAAK,CAMV;MAEN,CAAC,CAAC;IAzBF,CAyBE;IAEJ7C,kBAAY,GAAG,UAACqB,KAAK,EAAEoG,YAAY;MAC3B,SAAuBzH,KAAI,CAACO,KAAK,CAACG,IAAI;QAApCgH,MAAM;QAAEC,QAAQ,cAAoB;MAC5C,IAAMC,eAAe,GAAGvG,KAAK,IAAIqG,MAAM,CAACxD,MAAM,GAAG,CAAC,CAAC;MAEnD,OAAOwD,MAAM,CAACtB,GAAG,CAAC,UAACyB,UAAU,EAAE7G,CAAC;QAAK,OACnC,KAAC,CAAC;UAAA,UACA,KAAC,UAAU;YACT,KAAK,EAAEA,CAAE;YACT,SAAS,EAAEhB,KAAI,CAACgD,QAAQ,CAAC2E,QAAQ,CAAC3G,CAAC,CAAC,EAAE,GAAG,CAAE;YAC3C,eAAe,EAAE4G,eAAgB;YACjC,UAAU,EAAEC,UAAW;YACvB,UAAU,EAACC,aAAM9H,KAAI,CAAC+H,iBAAiB,EAAE,CAAG;YAC5C,YAAY,EAAEN;UAAa;QAE/B,GATQtE,IAAI,CAACC,MAAM,EAAE,CASjB;MAV+B,CAWpC,CAAC;IACJ,CAAC;;EA8MH;EA5ME4E,0BAAM,GAAN;IACQ,SAuBF,IAAI,CAACzH,KAAK;MAtBZc,KAAK;MACLC,MAAM;MACNZ,IAAI;MACJkD,yBAAyB;MAAzBoB,iBAAiB,mBAAG,KAAK;MACzBhD,kBAAiB;MAAjBiG,UAAU,mBAAG,IAAI;MACjB/F,gBAAe;MAAfK,QAAQ,mBAAG,IAAI;MACf2F,sBAAqB;MAArBC,cAAc,mBAAG,IAAI;MACrBC,sBAAqB;MAArBC,cAAc,mBAAG,IAAI;MACrBC,2BAA0B;MAA1BC,mBAAmB,mBAAG,IAAI;MAC1BC,yBAAwB;MAAxBC,iBAAiB,mBAAG,IAAI;MACxBC,4BAA2B;MAA3BC,oBAAoB,mBAAG,IAAI;MAC3BC,0BAAyB;MAAzBC,kBAAkB,mBAAG,IAAI;MACzBC,aAAU;MAAVC,KAAK,mBAAG,EAAE;MACVC,SAAS;MACTvH,gBAAgB;MAChBwH,6BAAyB;MAAzBC,qBAAqB,mBAAG,CAAC;MACzBC,+BAA2B;MAA3BC,uBAAuB,mBAAG,CAAC;MAC3BC,oBAA+B;MAA/BC,YAAY,mBAAG,gBAAM;QAAI,aAAM;MAAN,CAAM;MAC/BC,oBAA+B;MAA/BC,YAAY,mBAAG,gBAAM;QAAI,aAAM;MAAN,CAAM;MAC/BC,QAAQ;MACRC,mBAAmB;MAAnBC,WAAW,mBAAG,KAAK;MACnBnJ,WAAW,iBACC;IAEN,iCAA6B,GAAK,IAAI,CAACoJ,KAAK,8BAAf;IAC7B,SAAgBlJ,IAAI,OAAT;MAAXmJ,MAAM,mBAAG,EAAE;IAEjB,SAMEd,KAAK,aANS;MAAhBe,YAAY,mBAAG,CAAC;MAChBC,KAKEhB,KAAK,WALQ;MAAfxH,UAAU,mBAAG,EAAE;MACfyI,KAIEjB,KAAK,aAJU;MAAjBvH,YAAY,mBAAG,EAAE;MACjByI,KAGElB,KAAK,OAHG;MAAVmB,MAAM,mBAAG,CAAC;MACVC,KAEEpB,KAAK,YAFQ;MAAfqB,WAAW,mBAAG,CAAC;MACfC,KACEtB,KAAK,cADU;MAAjBuB,aAAa,mBAAG,CAAC;IAGnB,IAAMC,MAAM,GAAG;MACblJ,KAAK;MACLC,MAAM;MACN4H,qBAAqB;MACrBE,uBAAuB;KACxB;IAED,IAAMzH,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAClB,IAAI,CAACiH,QAAQ,CAAC;IAE1C,IAAI6C,KAAK,GAAGrH,IAAI,CAACsH,GAAG,OAARtH,IAAI,EAAQxB,KAAK,MAAMwB,IAAI,CAACuH,GAAG,OAARvH,IAAI,EAAQxB,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;IAC7D,IAAI8H,QAAQ,EAAE;MACZe,KAAK,GAAGf,QAAQ;;IAGlB,IAAMhC,YAAY,GAAG,IAAI,CAAClH,KAAK,CAACG,IAAI,CAACgH,MAAM,GAAGpG,MAAM,GAAG,IAAI,GAAG,CAAC;IAE/D,OACE,MAAC,IAAI;MAAC,KAAK,EAAEyH,KAAM;MAAA,WACjB,MAAC,GAAG;QACF,MAAM,EAAEzH,MAAM,GAAIgJ,aAAwB,GAAG7C,YAAa;QAC1D,KAAK,EAAEpG,KAAK,GAAI6I,MAAiB,GAAG,CAAC,GAAIE,WAAuB;QAAA,WAEhE,KAAC,IAAI;UACH,KAAK,EAAC,MAAM;UACZ,MAAM,EAAE9I,MAAM,GAAGmG,YAAa;UAC9B,EAAE,EAAEqC,YAAa;UACjB,EAAE,EAAEA,YAAa;UACjB,IAAI,EAAC,0BAA0B;UAC/B,WAAW,EAAEH,WAAW,GAAG,CAAC,GAAG;QAAE,EAEnC,EAAC,IAAI,CAACpJ,KAAK,CAACG,IAAI,CAACgH,MAAM,IACrB,IAAI,CAACiD,YAAY,CAACJ,MAAM,CAAClJ,KAAK,EAAEoG,YAAY,CAAC,EAC/C,MAAC,CAAC;UAAC,CAAC,EAAC,GAAG;UAAC,CAAC,EAAEA,YAAa;UAAA,WACtB,IAAI,CAACmD,UAAU,gCACXL,MAAM,GACN/J,WAAW;YACdE,IAAI,EAAEA,IAAI,CAACiH;UAAQ,GACnB,EACF,KAAC,CAAC;YAAA,UACCY,mBAAmB,KACjBJ,cAAc,GACX,IAAI,CAAC0C,qBAAqB,uBACrBN,MAAM;cACTC,KAAK,EAAEA,KAAK;cACZjJ,UAAU;cACVC,YAAY;YAAA,GACZ,GACF6G,cAAc,GACd,IAAI,CAACyC,oBAAoB,uBACpBP,MAAM;cACThJ,UAAU;cACVC,YAAY;YAAA,GACZ,GACF,IAAI;UAAC,EAEb,OAAC,CAAC;YAAA,UACCmH,oBAAoB,IACnB,IAAI,CAACoC,sBAAsB,uBACtBR,MAAM;cACTC,KAAK,EAAEA,KAAK;cACZ9J,IAAI,EAAEiB,KAAK;cACXJ,UAAU,EAAEA,UAAoB;cAChCC,YAAY,EAAEA,YAAsB;cACpC8H,YAAY;cACZ0B,aAAa,EAAExK,WAAW,CAACwK;YAAa;UACxC,EAEN,OAAC,CAAC;YAAA,UACCvC,iBAAiB,KACfN,cAAc,GACX,IAAI,CAAC8C,mBAAmB,uBACnBV,MAAM;cACT7J,IAAI,EAAEA,IAAI,CAACiH,QAAQ,CAAC,CAAC,CAAC,CAACjH,IAAI;cAC3Ba,UAAU,EAAEA,UAAoB;cAChCC,YAAY,EAAEA;YAAsB,GACpC,GACF6G,cAAc,GACd,IAAI,CAAC6C,kBAAkB,uBAClBX,MAAM;cACThJ,UAAU,EAAEA,UAAoB;cAChCC,YAAY,EAAEA;YAAsB,GACpC,GACF,IAAI;UAAC,EAEb,OAAC,CAAC;YAAA,UACCqH,kBAAkB,IACjB,IAAI,CAACsC,oBAAoB,uBACpBZ,MAAM;cACTV,MAAM;cACNtI,UAAU,EAAEA,UAAoB;cAChCC,YAAY,EAAEA,YAAsB;cACpCgI,YAAY;YAAA;UACZ,EAEN,OAAC,CAAC;YAAA,UACC,IAAI,CAAC4B,UAAU,gCACXb,MAAM,GACN/J,WAAW;cACdgB,YAAY,EAAEA,YAAsB;cACpCD,UAAU,EAAEA,UAAoB;cAChCb,IAAI,EAAEA,IAAI,CAACiH;YAAQ;UACnB,EAEJ,OAAC,CAAC;YAAA,UACCM,UAAU,IACT,IAAI,CAACoD,YAAY,uBACZd,MAAM;cACT7J,IAAI,EAAEA,IAAI,CAACiH,QAAQ;cACnBnG,YAAY,EAAEA,YAAsB;cACpCD,UAAU,EAAEA,UAAoB;cAChC0E,mBAAmB,EAAEzF,WAAW,CAAC8K;YAAyB;UAC1D,EAEN,OAAC,CAAC;YAAA,UACC/I,QAAQ,IACP,IAAI,CAACgJ,UAAU,uBACVhB,MAAM;cACT7J,IAAI,EAAEA,IAAI,CAACiH,QAAQ;cACnBpG,UAAU,EAAEA,UAAoB;cAChCC,YAAY,EAAEA,YAAsB;cACpCC,gBAAgB;YAAA;UAChB,EAEN,OAAC,CAAC;YAAA,UACCuD,iBAAiB,IAChB,IAAI,CAACwG,mBAAmB,gCACnBjB,MAAM,GACN/J,WAAW;cACdE,IAAI,EAAEA,IAAI,CAACiH,QAAQ;cACnBpG,UAAU,EAAEA,UAAoB;cAChCC,YAAY,EAAEA,YAAsB;cACpCC,gBAAgB;cAChBvB,6BAA6B;YAAA;UAC7B,EAEN,OAAC,CAAC;YAAA,UACC8I,SAAS,IACRA,SAAS,uBACJuB,MAAM;cACT7J,IAAI,EAAEA,IAAI,CAACiH,QAAQ;cACnBpG,UAAU;cACVC,YAAY;YAAA;UACZ,EAER;QAAA,EACF;MAAA,EACA,EAACwD,iBAAiB,IAChB,KAAC,UAAU;QACT,KAAK,EAAEyG,UAAU,CAACC,YAAa;QAC/B,qBAAqB,EAAE;UAAErK,KAAK,EAAEA,KAAK,GAAG;QAAC,CAAG;QAC5C,8BAA8B,EAAE,KAAM;QACtC,mBAAmB,EAAE,EAAG;QACxB,QAAQ,EAAExB,QAAQ,CAAC8L,KAAK,CAAC,CACvB;UACEC,WAAW,EAAE;YACXC,aAAa,EAAE;cAAE9K,CAAC,EAAEb;YAA6B;;SAEpD,CACF,EAAE;UAAE4L,eAAe,EAAE;QAAK,CAAE,CAC3B;QACF,UAAU;QACV,OAAO,EAAE;MAAM,EAElB;IAAA,EACI;EAEX,CAAC;EACH,gBAAC;AAAD,CAAC,CAxwBuBpM,aAAa;AA0wBrC,eAAesI,SAAS","names":["React","Circle","G","Path","Polygon","Polyline","Rect","Svg","AbstractChart","LegendItem","AnimatedCircle","Animated","createAnimatedComponent","__extends","_this","createRef","scrollableDotHorizontalOffset","Value","dataset","opacity","color","props","chartConfig","strokeWidth","data","reduce","acc","item","__spreadArrays","x","i","getDotProps","propsForDots","r","_a","width","height","paddingTop","paddingRight","onDataPointClick","output","datas","getDatas","baseHeight","calcBaseHeight","getDotColor","_c","hidePointsAtIndex","_d","renderDotContent","xMax","getXMaxValues","forEach","withDots","includes","cx","cy","calcHeight","onPress","index","value","y","getColor","push","getPropsForDots","Math","random","indexData","scrollableDotFill","scrollableDotStrokeColor","scrollableDotStrokeWidth","scrollableDotRadius","scrollableInfoViewStyle","scrollableInfoTextStyle","_b","scrollableInfoTextDecorator","scrollableInfoSize","scrollableInfoOffset","vl","perData","length","lastIndex","addListener","abs","floor","percent","label","current","setNativeProps","text","base","prev","rest","next","withScrollableDot","values","yValues","xValues","yValuesLabel","xValuesLabel","yval","xval","translateX","interpolate","inputRange","outputRange","extrapolate","translateY","labelTranslateX","labelTranslateY","transform","useColorFromDataset","bezier","renderBezierShadow","map","d","join","linejoinType","renderBezierLine","lastPoint","points","getStrokeWidth","strokeDashArray","strokeDashOffset","cur","yHeight","concat","slice","_","x_mid","y_mid","cp_x1","cp_x2","result","getBezierLinePoints","legendOffset","legend","datasets","baseLegendItemX","legendItem","__assign","getPropsForLabels","LineChart","withShadow","_e","withInnerLines","_f","withOuterLines","_g","withHorizontalLines","_h","withVerticalLines","_j","withHorizontalLabels","_k","withVerticalLabels","_l","style","decorator","_m","verticalLabelRotation","_o","horizontalLabelRotation","_p","formatYLabel","_q","formatXLabel","segments","_r","transparent","state","labels","borderRadius","_u","_v","_w","margin","_x","marginRight","_y","paddingBottom","config","count","min","max","renderLegend","renderDefs","renderHorizontalLines","renderHorizontalLine","renderHorizontalLabels","decimalPlaces","renderVerticalLines","renderVerticalLine","renderVerticalLabels","renderLine","renderShadow","useShadowColorFromDataset","renderDots","renderScrollableDot","StyleSheet","absoluteFill","event","nativeEvent","contentOffset","useNativeDriver"],"sourceRoot":"","sources":["../../src/line-chart/LineChart.tsx"],"sourcesContent":["import React, { ReactNode } from \"react\";\nimport {\n  Animated,\n  ScrollView,\n  StyleSheet,\n  TextInput,\n  View,\n  ViewStyle\n} from \"react-native\";\nimport {\n  Circle,\n  G,\n  Path,\n  Polygon,\n  Polyline,\n  Rect,\n  Svg\n} from \"react-native-svg\";\n\nimport AbstractChart, {\n  AbstractChartConfig,\n  AbstractChartProps\n} from \"../AbstractChart\";\nimport { ChartData, Dataset } from \"../HelperTypes\";\nimport { LegendItem } from \"./LegendItem\";\n\nlet AnimatedCircle = Animated.createAnimatedComponent(Circle);\n\nexport interface LineChartData extends ChartData {\n  legend?: string[];\n}\n\nexport interface LineChartProps extends AbstractChartProps {\n  /**\n   * Data for the chart.\n   *\n   * Example from [docs](https://github.com/indiespirit/react-native-chart-kit#line-chart):\n   *\n   * ```javascript\n   * const data = {\n   *   labels: ['January', 'February', 'March', 'April', 'May', 'June'],\n   *   datasets: [{\n   *     data: [ 20, 45, 28, 80, 99, 43 ],\n   *     color: (opacity = 1) => `rgba(134, 65, 244, ${opacity})`, // optional\n   *     strokeWidth: 2 // optional\n   *   }],\n   *   legend: [\"Rainy Days\", \"Sunny Days\", \"Snowy Days\"] // optional\n   * }\n   * ```\n   */\n  data: LineChartData;\n  /**\n   * Width of the chart, use 'Dimensions' library to get the width of your screen for responsive.\n   */\n  width: number;\n  /**\n   * Height of the chart.\n   */\n  height: number;\n  /**\n   * Show dots on the line - default: True.\n   */\n  withDots?: boolean;\n  /**\n   * Show shadow for line - default: True.\n   */\n  withShadow?: boolean;\n  /**\n   * Show inner dashed lines - default: True.\n   */\n\n  withScrollableDot?: boolean;\n  withInnerLines?: boolean;\n  /**\n   * Show outer dashed lines - default: True.\n   */\n  withOuterLines?: boolean;\n  /**\n   * Show vertical lines - default: True.\n   */\n  withVerticalLines?: boolean;\n  /**\n   * Show horizontal lines - default: True.\n   */\n  withHorizontalLines?: boolean;\n  /**\n   * Show vertical labels - default: True.\n   */\n  withVerticalLabels?: boolean;\n  /**\n   * Show horizontal labels - default: True.\n   */\n  withHorizontalLabels?: boolean;\n  /**\n   * Render charts from 0 not from the minimum value. - default: False.\n   */\n  fromZero?: boolean;\n  /**\n   * Prepend text to horizontal labels -- default: ''.\n   */\n  yAxisLabel?: string;\n  /**\n   * Append text to horizontal labels -- default: ''.\n   */\n  yAxisSuffix?: string;\n  /**\n   * Prepend text to vertical labels -- default: ''.\n   */\n  xAxisLabel?: string;\n  /**\n   * Configuration object for the chart, see example:\n   *\n   * ```javascript\n   * const chartConfig = {\n   *   backgroundGradientFrom: \"#1E2923\",\n   *   backgroundGradientFromOpacity: 0,\n   *   backgroundGradientTo: \"#08130D\",\n   *   backgroundGradientToOpacity: 0.5,\n   *   color: (opacity = 1) => `rgba(26, 255, 146, ${opacity})`,\n   *   labelColor: (opacity = 1) => `rgba(26, 255, 146, ${opacity})`,\n   *   strokeWidth: 2, // optional, default 3\n   *   barPercentage: 0.5\n   * };\n   * ```\n   */\n  chartConfig?: AbstractChartConfig;\n\n  /**\n   * Divide axis quantity by the input number -- default: 1.\n   */\n  yAxisInterval?: number;\n\n  /**\n   * Defines if chart is transparent\n   */\n  transparent?: boolean;\n  /**\n   * This function takes a [whole bunch](https://github.com/indiespirit/react-native-chart-kit/blob/master/src/line-chart.js#L266)\n   * of stuff and can render extra elements,\n   * such as data point info or additional markup.\n   */\n  decorator?: Function;\n  /**\n   * Callback that is called when a data point is clicked.\n   */\n  onDataPointClick?: (data: {\n    index: number;\n    value: number;\n    dataset: Dataset;\n    x: number;\n    y: number;\n    getColor: (opacity: number) => string;\n  }) => void;\n  /**\n   * Style of the container view of the chart.\n   */\n  style?: Partial<ViewStyle>;\n  /**\n   * Add this prop to make the line chart smooth and curvy.\n   *\n   * [Example](https://github.com/indiespirit/react-native-chart-kit#bezier-line-chart)\n   */\n  bezier?: boolean;\n  /**\n   * Defines the dot color function that is used to calculate colors of dots in a line chart.\n   * Takes `(dataPoint, dataPointIndex)` as arguments.\n   */\n  getDotColor?: (dataPoint: any, index: number) => string;\n  /**\n   * Renders additional content for dots in a line chart.\n   * Takes `({x, y, index})` as arguments.\n   */\n  renderDotContent?: (params: {\n    x: number;\n    y: number;\n    index: number;\n    indexData: number;\n  }) => React.ReactNode;\n  /**\n   * Rotation angle of the horizontal labels - default 0 (degrees).\n   */\n  horizontalLabelRotation?: number;\n  /**\n   * Rotation angle of the vertical labels - default 0 (degrees).\n   */\n  verticalLabelRotation?: number;\n  /**\n   * Offset for Y axis labels.\n   */\n  yLabelsOffset?: number;\n  /**\n   * Offset for X axis labels.\n   */\n  xLabelsOffset?: number;\n  /**\n   * Array of indices of the data points you don't want to display.\n   */\n  hidePointsAtIndex?: number[];\n  /**\n   * This function change the format of the display value of the Y label.\n   * Takes the y value as argument and should return the desirable string.\n   */\n  formatYLabel?: (yValue: string) => string;\n  /**\n   * This function change the format of the display value of the X label.\n   * Takes the X value as argument and should return the desirable string.\n   */\n  formatXLabel?: (xValue: string) => string;\n  /**\n   * Provide props for a data point dot.\n   */\n  getDotProps?: (dataPoint: any, index: number) => object;\n  /**\n   * The number of horizontal lines\n   */\n  segments?: number;\n}\n\ntype LineChartState = {\n  scrollableDotHorizontalOffset: Animated.Value;\n};\n\nclass LineChart extends AbstractChart<LineChartProps, LineChartState> {\n  label = React.createRef<TextInput>();\n\n  state = {\n    scrollableDotHorizontalOffset: new Animated.Value(0)\n  };\n\n  getColor = (dataset: Dataset, opacity: number) => {\n    return (dataset.color || this.props.chartConfig.color)(opacity);\n  };\n\n  getStrokeWidth = (dataset: Dataset) => {\n    return dataset.strokeWidth || this.props.chartConfig.strokeWidth || 3;\n  };\n\n  getDatas = (data: Dataset[]): number[] => {\n    return data.reduce(\n      (acc, item) => (item.data ? [...acc, ...item.data] : acc),\n      []\n    );\n  };\n\n  getPropsForDots = (x: any, i: number) => {\n    const { getDotProps, chartConfig } = this.props;\n\n    if (typeof getDotProps === \"function\") {\n      return getDotProps(x, i);\n    }\n\n    const { propsForDots = {} } = chartConfig;\n\n    return { r: \"4\", ...propsForDots };\n  };\n\n  renderDots = ({\n    data,\n    width,\n    height,\n    paddingTop,\n    paddingRight,\n    onDataPointClick\n  }: Pick<\n    AbstractChartConfig,\n    \"data\" | \"width\" | \"height\" | \"paddingRight\" | \"paddingTop\"\n  > & {\n    onDataPointClick: LineChartProps[\"onDataPointClick\"];\n  }) => {\n    const output: ReactNode[] = [];\n    const datas = this.getDatas(data);\n    const baseHeight = this.calcBaseHeight(datas, height);\n\n    const {\n      getDotColor,\n      hidePointsAtIndex = [],\n      renderDotContent = () => {\n        return null;\n      }\n    } = this.props;\n    const xMax = this.getXMaxValues(data);\n    data.forEach(dataset => {\n      if (dataset.withDots == false) return;\n\n      dataset.data.forEach((x, i) => {\n        if (hidePointsAtIndex.includes(i)) {\n          return;\n        }\n\n        const cx = paddingRight + (i * (width - paddingRight)) / xMax;\n\n        const cy =\n          ((baseHeight - this.calcHeight(x, datas, height)) / 4) * 3 +\n          paddingTop;\n\n        const onPress = () => {\n          if (!onDataPointClick || hidePointsAtIndex.includes(i)) {\n            return;\n          }\n\n          onDataPointClick({\n            index: i,\n            value: x,\n            dataset,\n            x: cx,\n            y: cy,\n            getColor: opacity => this.getColor(dataset, opacity)\n          });\n        };\n\n        output.push(\n          <Circle\n            key={Math.random()}\n            cx={cx}\n            cy={cy}\n            fill={\n              typeof getDotColor === \"function\"\n                ? getDotColor(x, i)\n                : this.getColor(dataset, 0.9)\n            }\n            onPress={onPress}\n            {...this.getPropsForDots(x, i)}\n          />,\n          <Circle\n            key={Math.random()}\n            cx={cx}\n            cy={cy}\n            r=\"14\"\n            fill=\"#fff\"\n            fillOpacity={0}\n            onPress={onPress}\n          />,\n          renderDotContent({ x: cx, y: cy, index: i, indexData: x })\n        );\n      });\n    });\n\n    return output;\n  };\n\n  renderScrollableDot = ({\n    data,\n    width,\n    height,\n    paddingTop,\n    paddingRight,\n    scrollableDotHorizontalOffset,\n    scrollableDotFill,\n    scrollableDotStrokeColor,\n    scrollableDotStrokeWidth,\n    scrollableDotRadius,\n    scrollableInfoViewStyle,\n    scrollableInfoTextStyle,\n    scrollableInfoTextDecorator = x => `${x}`,\n    scrollableInfoSize,\n    scrollableInfoOffset\n  }: AbstractChartConfig & {\n    onDataPointClick: LineChartProps[\"onDataPointClick\"];\n    scrollableDotHorizontalOffset: Animated.Value;\n  }) => {\n    const output = [];\n    const datas = this.getDatas(data);\n    const baseHeight = this.calcBaseHeight(datas, height);\n\n    let vl: number[] = [];\n\n    const perData = width / data[0].data.length;\n    for (let index = 0; index < data[0].data.length; index++) {\n      vl.push(index * perData);\n    }\n    let lastIndex: number;\n\n    scrollableDotHorizontalOffset.addListener(value => {\n      const index = value.value / perData;\n      if (!lastIndex) {\n        lastIndex = index;\n      }\n\n      let abs = Math.floor(index);\n      let percent = index - abs;\n      abs = data[0].data.length - abs - 1;\n\n      if (index >= data[0].data.length - 1) {\n        this.label.current.setNativeProps({\n          text: scrollableInfoTextDecorator(Math.floor(data[0].data[0]))\n        });\n      } else {\n        if (index > lastIndex) {\n          // to right\n\n          const base = data[0].data[abs];\n          const prev = data[0].data[abs - 1];\n          if (prev > base) {\n            let rest = prev - base;\n            this.label.current.setNativeProps({\n              text: scrollableInfoTextDecorator(\n                Math.floor(base + percent * rest)\n              )\n            });\n          } else {\n            let rest = base - prev;\n            this.label.current.setNativeProps({\n              text: scrollableInfoTextDecorator(\n                Math.floor(base - percent * rest)\n              )\n            });\n          }\n        } else {\n          // to left\n\n          const base = data[0].data[abs - 1];\n          const next = data[0].data[abs];\n          percent = 1 - percent;\n          if (next > base) {\n            let rest = next - base;\n            this.label.current.setNativeProps({\n              text: scrollableInfoTextDecorator(\n                Math.floor(base + percent * rest)\n              )\n            });\n          } else {\n            let rest = base - next;\n            this.label.current.setNativeProps({\n              text: scrollableInfoTextDecorator(\n                Math.floor(base - percent * rest)\n              )\n            });\n          }\n        }\n      }\n      lastIndex = index;\n    });\n\n    data.forEach(dataset => {\n      if (dataset.withScrollableDot == false) return;\n\n      const perData = width / dataset.data.length;\n      let values = [];\n      let yValues = [];\n      let xValues = [];\n\n      let yValuesLabel = [];\n      let xValuesLabel = [];\n\n      for (let index = 0; index < dataset.data.length; index++) {\n        values.push(index * perData);\n        const yval =\n          ((baseHeight -\n            this.calcHeight(\n              dataset.data[dataset.data.length - index - 1],\n              datas,\n              height\n            )) /\n            4) *\n            3 +\n          paddingTop;\n        yValues.push(yval);\n        const xval =\n          paddingRight +\n          ((dataset.data.length - index - 1) * (width - paddingRight)) /\n            dataset.data.length;\n        xValues.push(xval);\n\n        yValuesLabel.push(\n          yval - (scrollableInfoSize.height + scrollableInfoOffset)\n        );\n        xValuesLabel.push(xval - scrollableInfoSize.width / 2);\n      }\n\n      const translateX = scrollableDotHorizontalOffset.interpolate({\n        inputRange: values,\n        outputRange: xValues,\n        extrapolate: \"clamp\"\n      });\n\n      const translateY = scrollableDotHorizontalOffset.interpolate({\n        inputRange: values,\n        outputRange: yValues,\n        extrapolate: \"clamp\"\n      });\n\n      const labelTranslateX = scrollableDotHorizontalOffset.interpolate({\n        inputRange: values,\n        outputRange: xValuesLabel,\n        extrapolate: \"clamp\"\n      });\n\n      const labelTranslateY = scrollableDotHorizontalOffset.interpolate({\n        inputRange: values,\n        outputRange: yValuesLabel,\n        extrapolate: \"clamp\"\n      });\n\n      output.push([\n        <Animated.View\n          key={Math.random()}\n          style={[\n            scrollableInfoViewStyle,\n            {\n              transform: [\n                { translateX: labelTranslateX },\n                { translateY: labelTranslateY }\n              ],\n              width: scrollableInfoSize.width,\n              height: scrollableInfoSize.height\n            }\n          ]}\n        >\n          <TextInput\n            onLayout={() => {\n              this.label.current.setNativeProps({\n                text: scrollableInfoTextDecorator(\n                  Math.floor(data[0].data[data[0].data.length - 1])\n                )\n              });\n            }}\n            style={scrollableInfoTextStyle}\n            ref={this.label}\n          />\n        </Animated.View>,\n        <AnimatedCircle\n          key={Math.random()}\n          cx={translateX}\n          cy={translateY}\n          r={scrollableDotRadius}\n          stroke={scrollableDotStrokeColor}\n          strokeWidth={scrollableDotStrokeWidth}\n          fill={scrollableDotFill}\n        />\n      ]);\n    });\n\n    return output;\n  };\n\n  renderShadow = ({\n    width,\n    height,\n    paddingRight,\n    paddingTop,\n    data,\n    useColorFromDataset\n  }: Pick<\n    AbstractChartConfig,\n    \"data\" | \"width\" | \"height\" | \"paddingRight\" | \"paddingTop\"\n  > & {\n    useColorFromDataset: AbstractChartConfig[\"useShadowColorFromDataset\"];\n  }) => {\n    if (this.props.bezier) {\n      return this.renderBezierShadow({\n        width,\n        height,\n        paddingRight,\n        paddingTop,\n        data,\n        useColorFromDataset\n      });\n    }\n\n    const datas = this.getDatas(data);\n    const baseHeight = this.calcBaseHeight(datas, height);\n\n    return data.map((dataset, index) => {\n      return (\n        <Polygon\n          key={index}\n          points={\n            dataset.data\n              .map((d, i) => {\n                const x =\n                  paddingRight +\n                  (i * (width - paddingRight)) / dataset.data.length;\n\n                const y =\n                  ((baseHeight - this.calcHeight(d, datas, height)) / 4) * 3 +\n                  paddingTop;\n\n                return `${x},${y}`;\n              })\n              .join(\" \") +\n            ` ${paddingRight +\n              ((width - paddingRight) / dataset.data.length) *\n                (dataset.data.length - 1)},${(height / 4) * 3 +\n              paddingTop} ${paddingRight},${(height / 4) * 3 + paddingTop}`\n          }\n          fill={`url(#fillShadowGradientFrom${\n            useColorFromDataset ? `_${index}` : \"\"\n          })`}\n          strokeWidth={0}\n        />\n      );\n    });\n  };\n\n  renderLine = ({\n    width,\n    height,\n    paddingRight,\n    paddingTop,\n    data,\n    linejoinType\n  }: Pick<\n    AbstractChartConfig,\n    \"data\" | \"width\" | \"height\" | \"paddingRight\" | \"paddingTop\" | \"linejoinType\"\n  >) => {\n    if (this.props.bezier) {\n      return this.renderBezierLine({\n        data,\n        width,\n        height,\n        paddingRight,\n        paddingTop\n      });\n    }\n\n    const output = [];\n    const datas = this.getDatas(data);\n    const baseHeight = this.calcBaseHeight(datas, height);\n    const xMax = this.getXMaxValues(data);\n\n    let lastPoint: string;\n\n    data.forEach((dataset, index) => {\n      const points = dataset.data.map((d, i) => {\n        if (d === null) return lastPoint;\n        const x = (i * (width - paddingRight)) / xMax + paddingRight;\n        const y =\n          ((baseHeight - this.calcHeight(d, datas, height)) / 4) * 3 +\n          paddingTop;\n        lastPoint = `${x},${y}`;\n        return `${x},${y}`;\n      });\n\n      output.push(\n        <Polyline\n          key={index}\n          strokeLinejoin={linejoinType}\n          points={points.join(\" \")}\n          fill=\"none\"\n          stroke={this.getColor(dataset, 0.2)}\n          strokeWidth={this.getStrokeWidth(dataset)}\n          strokeDasharray={dataset.strokeDashArray}\n          strokeDashoffset={dataset.strokeDashOffset}\n        />\n      );\n    });\n\n    return output;\n  };\n\n  getXMaxValues = (data: Dataset[]) => {\n    return data.reduce((acc, cur) => {\n      return cur.data.length > acc ? cur.data.length : acc;\n    }, 0);\n  };\n\n  getBezierLinePoints = (\n    dataset: Dataset,\n    {\n      width,\n      height,\n      paddingRight,\n      paddingTop,\n      data\n    }: Pick<\n      AbstractChartConfig,\n      \"width\" | \"height\" | \"paddingRight\" | \"paddingTop\" | \"data\"\n    >\n  ) => {\n    if (dataset.data.length === 0) {\n      return \"M0,0\";\n    }\n\n    const datas = this.getDatas(data);\n    const xMax = this.getXMaxValues(data);\n\n    const x = (i: number) =>\n      Math.floor(paddingRight + (i * (width - paddingRight)) / xMax);\n\n    const baseHeight = this.calcBaseHeight(datas, height);\n\n    const y = (i: number) => {\n      const yHeight = this.calcHeight(dataset.data[i], datas, height);\n\n      return Math.floor(((baseHeight - yHeight) / 4) * 3 + paddingTop);\n    };\n\n    return [`M${x(0)},${y(0)}`]\n      .concat(\n        dataset.data.slice(0, -1).map((_, i) => {\n          const x_mid = (x(i) + x(i + 1)) / 2;\n          const y_mid = (y(i) + y(i + 1)) / 2;\n          const cp_x1 = (x_mid + x(i)) / 2;\n          const cp_x2 = (x_mid + x(i + 1)) / 2;\n          return (\n            `Q ${cp_x1}, ${y(i)}, ${x_mid}, ${y_mid}` +\n            ` Q ${cp_x2}, ${y(i + 1)}, ${x(i + 1)}, ${y(i + 1)}`\n          );\n        })\n      )\n      .join(\" \");\n  };\n\n  renderBezierLine = ({\n    data,\n    width,\n    height,\n    paddingRight,\n    paddingTop\n  }: Pick<\n    AbstractChartConfig,\n    \"data\" | \"width\" | \"height\" | \"paddingRight\" | \"paddingTop\"\n  >) => {\n    return data.map((dataset, index) => {\n      const result = this.getBezierLinePoints(dataset, {\n        width,\n        height,\n        paddingRight,\n        paddingTop,\n        data\n      });\n\n      return (\n        <Path\n          key={index}\n          d={result}\n          fill=\"none\"\n          stroke={this.getColor(dataset, 0.2)}\n          strokeWidth={this.getStrokeWidth(dataset)}\n          strokeDasharray={dataset.strokeDashArray}\n          strokeDashoffset={dataset.strokeDashOffset}\n        />\n      );\n    });\n  };\n\n  renderBezierShadow = ({\n    width,\n    height,\n    paddingRight,\n    paddingTop,\n    data,\n    useColorFromDataset\n  }: Pick<\n    AbstractChartConfig,\n    \"data\" | \"width\" | \"height\" | \"paddingRight\" | \"paddingTop\"\n  > & {\n    useColorFromDataset: AbstractChartConfig[\"useShadowColorFromDataset\"];\n  }) =>\n    data.map((dataset, index) => {\n      const xMax = this.getXMaxValues(data);\n      const d =\n        this.getBezierLinePoints(dataset, {\n          width,\n          height,\n          paddingRight,\n          paddingTop,\n          data\n        }) +\n        ` L${paddingRight +\n          ((width - paddingRight) / xMax) *\n            (dataset.data.length - 1)},${(height / 4) * 3 +\n          paddingTop} L${paddingRight},${(height / 4) * 3 + paddingTop} Z`;\n\n      return (\n        <Path\n          key={index}\n          d={d}\n          fill={`url(#fillShadowGradientFrom${\n            useColorFromDataset ? `_${index}` : \"\"\n          })`}\n          strokeWidth={0}\n        />\n      );\n    });\n\n  renderLegend = (width, legendOffset) => {\n    const { legend, datasets } = this.props.data;\n    const baseLegendItemX = width / (legend.length + 1);\n\n    return legend.map((legendItem, i) => (\n      <G key={Math.random()}>\n        <LegendItem\n          index={i}\n          iconColor={this.getColor(datasets[i], 0.9)}\n          baseLegendItemX={baseLegendItemX}\n          legendText={legendItem}\n          labelProps={{ ...this.getPropsForLabels() }}\n          legendOffset={legendOffset}\n        />\n      </G>\n    ));\n  };\n\n  render() {\n    const {\n      width,\n      height,\n      data,\n      withScrollableDot = false,\n      withShadow = true,\n      withDots = true,\n      withInnerLines = true,\n      withOuterLines = true,\n      withHorizontalLines = true,\n      withVerticalLines = true,\n      withHorizontalLabels = true,\n      withVerticalLabels = true,\n      style = {},\n      decorator,\n      onDataPointClick,\n      verticalLabelRotation = 0,\n      horizontalLabelRotation = 0,\n      formatYLabel = yLabel => yLabel,\n      formatXLabel = xLabel => xLabel,\n      segments,\n      transparent = false,\n      chartConfig\n    } = this.props;\n\n    const { scrollableDotHorizontalOffset } = this.state;\n    const { labels = [] } = data;\n    const {\n      borderRadius = 0,\n      paddingTop = 16,\n      paddingRight = 64,\n      margin = 0,\n      marginRight = 0,\n      paddingBottom = 0\n    } = style;\n\n    const config = {\n      width,\n      height,\n      verticalLabelRotation,\n      horizontalLabelRotation\n    };\n\n    const datas = this.getDatas(data.datasets);\n\n    let count = Math.min(...datas) === Math.max(...datas) ? 1 : 4;\n    if (segments) {\n      count = segments;\n    }\n\n    const legendOffset = this.props.data.legend ? height * 0.15 : 0;\n\n    return (\n      <View style={style}>\n        <Svg\n          height={height + (paddingBottom as number) + legendOffset}\n          width={width - (margin as number) * 2 - (marginRight as number)}\n        >\n          <Rect\n            width=\"100%\"\n            height={height + legendOffset}\n            rx={borderRadius}\n            ry={borderRadius}\n            fill=\"url(#backgroundGradient)\"\n            fillOpacity={transparent ? 0 : 1}\n          />\n          {this.props.data.legend &&\n            this.renderLegend(config.width, legendOffset)}\n          <G x=\"0\" y={legendOffset}>\n            {this.renderDefs({\n              ...config,\n              ...chartConfig,\n              data: data.datasets\n            })}\n            <G>\n              {withHorizontalLines &&\n                (withInnerLines\n                  ? this.renderHorizontalLines({\n                      ...config,\n                      count: count,\n                      paddingTop,\n                      paddingRight\n                    })\n                  : withOuterLines\n                  ? this.renderHorizontalLine({\n                      ...config,\n                      paddingTop,\n                      paddingRight\n                    })\n                  : null)}\n            </G>\n            <G>\n              {withHorizontalLabels &&\n                this.renderHorizontalLabels({\n                  ...config,\n                  count: count,\n                  data: datas,\n                  paddingTop: paddingTop as number,\n                  paddingRight: paddingRight as number,\n                  formatYLabel,\n                  decimalPlaces: chartConfig.decimalPlaces\n                })}\n            </G>\n            <G>\n              {withVerticalLines &&\n                (withInnerLines\n                  ? this.renderVerticalLines({\n                      ...config,\n                      data: data.datasets[0].data,\n                      paddingTop: paddingTop as number,\n                      paddingRight: paddingRight as number\n                    })\n                  : withOuterLines\n                  ? this.renderVerticalLine({\n                      ...config,\n                      paddingTop: paddingTop as number,\n                      paddingRight: paddingRight as number\n                    })\n                  : null)}\n            </G>\n            <G>\n              {withVerticalLabels &&\n                this.renderVerticalLabels({\n                  ...config,\n                  labels,\n                  paddingTop: paddingTop as number,\n                  paddingRight: paddingRight as number,\n                  formatXLabel\n                })}\n            </G>\n            <G>\n              {this.renderLine({\n                ...config,\n                ...chartConfig,\n                paddingRight: paddingRight as number,\n                paddingTop: paddingTop as number,\n                data: data.datasets\n              })}\n            </G>\n            <G>\n              {withShadow &&\n                this.renderShadow({\n                  ...config,\n                  data: data.datasets,\n                  paddingRight: paddingRight as number,\n                  paddingTop: paddingTop as number,\n                  useColorFromDataset: chartConfig.useShadowColorFromDataset\n                })}\n            </G>\n            <G>\n              {withDots &&\n                this.renderDots({\n                  ...config,\n                  data: data.datasets,\n                  paddingTop: paddingTop as number,\n                  paddingRight: paddingRight as number,\n                  onDataPointClick\n                })}\n            </G>\n            <G>\n              {withScrollableDot &&\n                this.renderScrollableDot({\n                  ...config,\n                  ...chartConfig,\n                  data: data.datasets,\n                  paddingTop: paddingTop as number,\n                  paddingRight: paddingRight as number,\n                  onDataPointClick,\n                  scrollableDotHorizontalOffset\n                })}\n            </G>\n            <G>\n              {decorator &&\n                decorator({\n                  ...config,\n                  data: data.datasets,\n                  paddingTop,\n                  paddingRight\n                })}\n            </G>\n          </G>\n        </Svg>\n        {withScrollableDot && (\n          <ScrollView\n            style={StyleSheet.absoluteFill}\n            contentContainerStyle={{ width: width * 2 }}\n            showsHorizontalScrollIndicator={false}\n            scrollEventThrottle={16}\n            onScroll={Animated.event([\n              {\n                nativeEvent: {\n                  contentOffset: { x: scrollableDotHorizontalOffset }\n                }\n              }\n            ], { useNativeDriver: false }\n            )}\n            horizontal\n            bounces={false}\n          />\n        )}\n      </View>\n    );\n  }\n}\n\nexport default LineChart;\n"]},"metadata":{},"sourceType":"module"}