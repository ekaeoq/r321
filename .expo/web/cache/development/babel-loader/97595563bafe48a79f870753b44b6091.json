{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { Platform } from 'expo-modules-core';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\nimport { AuthRequest } from \"./AuthRequest\";\nimport { CodeChallengeMethod, Prompt, ResponseType } from \"./AuthRequest.types\";\nimport { fetchDiscoveryAsync, resolveDiscoveryAsync } from \"./Discovery\";\nimport { generateHexStringAsync } from \"./PKCE\";\nimport { getQueryParams } from \"./QueryParams\";\nimport sessionUrlProvider from \"./SessionUrlProvider\";\nvar _authLock = false;\nexport function startAsync(_x) {\n  return _startAsync.apply(this, arguments);\n}\nfunction _startAsync() {\n  _startAsync = _asyncToGenerator(function* (options) {\n    var authUrl = options.authUrl;\n    if (!authUrl) {\n      throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n    }\n    if (_authLock) {\n      if (__DEV__) {\n        console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n      }\n      return {\n        type: 'locked'\n      };\n    }\n    var returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n    var startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl, options.projectNameForProxy);\n    var showInRecents = options.showInRecents || false;\n    _authLock = true;\n    var result;\n    try {\n      result = yield _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n    } finally {\n      _authLock = false;\n    }\n    if (!result) {\n      throw new Error('Unexpected missing AuthSession result');\n    }\n    if (!('url' in result)) {\n      if ('type' in result) {\n        return result;\n      } else {\n        throw new Error('Unexpected AuthSession result with missing type');\n      }\n    }\n    var _getQueryParams = getQueryParams(result.url),\n      params = _getQueryParams.params,\n      errorCode = _getQueryParams.errorCode;\n    return {\n      type: errorCode ? 'error' : 'success',\n      params: params,\n      errorCode: errorCode,\n      authentication: null,\n      url: result.url\n    };\n  });\n  return _startAsync.apply(this, arguments);\n}\nexport function dismiss() {\n  dismissAuthSession();\n}\nexport var getDefaultReturnUrl = sessionUrlProvider.getDefaultReturnUrl;\nexport function getRedirectUrl(path) {\n  return sessionUrlProvider.getRedirectUrl({\n    urlPath: path\n  });\n}\nexport function makeRedirectUri() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    native = _ref.native,\n    scheme = _ref.scheme,\n    isTripleSlashed = _ref.isTripleSlashed,\n    queryParams = _ref.queryParams,\n    path = _ref.path,\n    preferLocalhost = _ref.preferLocalhost,\n    useProxy = _ref.useProxy,\n    projectNameForProxy = _ref.projectNameForProxy;\n  if (Platform.OS !== 'web' && native && [ExecutionEnvironment.Standalone, ExecutionEnvironment.Bare].includes(Constants.executionEnvironment)) {\n    return native;\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    var url = Linking.createURL(path || '', {\n      isTripleSlashed: isTripleSlashed,\n      scheme: scheme,\n      queryParams: queryParams\n    });\n    if (preferLocalhost) {\n      var ipAddress = url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);\n      if (ipAddress != null && ipAddress.length) {\n        var _url$split = url.split(ipAddress[0]),\n          _url$split2 = _slicedToArray(_url$split, 2),\n          protocol = _url$split2[0],\n          _path = _url$split2[1];\n        return protocol + \"localhost\" + _path;\n      }\n    }\n    return url;\n  }\n  return sessionUrlProvider.getRedirectUrl({\n    urlPath: path,\n    projectNameForProxy: projectNameForProxy\n  });\n}\nexport function loadAsync(_x2, _x3) {\n  return _loadAsync.apply(this, arguments);\n}\nfunction _loadAsync() {\n  _loadAsync = _asyncToGenerator(function* (config, issuerOrDiscovery) {\n    var request = new AuthRequest(config);\n    var discovery = yield resolveDiscoveryAsync(issuerOrDiscovery);\n    yield request.makeAuthUrlAsync(discovery);\n    return request;\n  });\n  return _loadAsync.apply(this, arguments);\n}\nfunction _openWebBrowserAsync(_x4, _x5, _x6) {\n  return _openWebBrowserAsync2.apply(this, arguments);\n}\nfunction _openWebBrowserAsync2() {\n  _openWebBrowserAsync2 = _asyncToGenerator(function* (startUrl, returnUrl, showInRecents) {\n    var result = yield openAuthSessionAsync(startUrl, returnUrl, {\n      showInRecents: showInRecents\n    });\n    if (result.type === 'cancel' || result.type === 'dismiss') {\n      return {\n        type: result.type\n      };\n    }\n    return result;\n  });\n  return _openWebBrowserAsync2.apply(this, arguments);\n}\nexport { useAutoDiscovery, useAuthRequest } from \"./AuthRequestHooks\";\nexport { AuthError, TokenError } from \"./Errors\";\nexport { AuthRequest, CodeChallengeMethod, Prompt, ResponseType, resolveDiscoveryAsync, fetchDiscoveryAsync, generateHexStringAsync };\nexport {\nTokenResponse, AccessTokenRequest, RefreshTokenRequest, RevokeTokenRequest,\nrevokeAsync, refreshAsync, exchangeCodeAsync, fetchUserInfoAsync } from \"./TokenRequest\";\nexport * from \"./TokenRequest.types\";","map":{"version":3,"mappings":"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","names":["Constants","ExecutionEnvironment","Linking","Platform","dismissAuthSession","openAuthSessionAsync","AuthRequest","CodeChallengeMethod","Prompt","ResponseType","fetchDiscoveryAsync","resolveDiscoveryAsync","generateHexStringAsync","getQueryParams","sessionUrlProvider","_authLock","startAsync","options","authUrl","Error","__DEV__","console","warn","type","returnUrl","getDefaultReturnUrl","startUrl","getStartUrl","projectNameForProxy","showInRecents","result","_openWebBrowserAsync","url","params","errorCode","authentication","dismiss","getRedirectUrl","path","urlPath","makeRedirectUri","native","scheme","isTripleSlashed","queryParams","preferLocalhost","useProxy","OS","Standalone","Bare","includes","executionEnvironment","createURL","ipAddress","match","length","split","protocol","loadAsync","config","issuerOrDiscovery","request","discovery","makeAuthUrlAsync","useAutoDiscovery","useAuthRequest","AuthError","TokenError","TokenResponse","AccessTokenRequest","RefreshTokenRequest","RevokeTokenRequest","revokeAsync","refreshAsync","exchangeCodeAsync","fetchUserInfoAsync"],"sourceRoot":"","sources":["../src/AuthSession.ts"],"sourcesContent":["import Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { Platform } from 'expo-modules-core';\nimport {\n  dismissAuthSession,\n  openAuthSessionAsync,\n  WebBrowserAuthSessionResult,\n} from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport sessionUrlProvider from './SessionUrlProvider';\n\nlet _authLock = false;\n\n// @needsAudit\n/**\n * Initiate a proxied authentication session with the given options. Only one `AuthSession` can be active at any given time in your application.\n * If you attempt to open a second session while one is still in progress, the second session will return a value to indicate that `AuthSession` is locked.\n *\n * @param options An object of type `AuthSessionOptions`.\n * @return Returns a Promise that resolves to an `AuthSessionResult` object.\n */\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const authUrl = options.authUrl;\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl, options.projectNameForProxy);\n  const showInRecents = options.showInRecents || false;\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result: WebBrowserAuthSessionResult;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!('url' in result)) {\n    if ('type' in result) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\n// @needsAudit\n/**\n * Cancels an active `AuthSession` if there is one. No return value, but if there is an active `AuthSession`\n * then the Promise returned by the `AuthSession.startAsync()` that initiated it resolves to `{ type: 'dismiss' }`.\n */\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport const getDefaultReturnUrl = sessionUrlProvider.getDefaultReturnUrl;\n\n// @needsAudit @docsMissing\n/**\n * Get the URL that your authentication provider needs to redirect to. For example: `https://auth.expo.io/@your-username/your-app-slug`. You can pass an additional path component to be appended to the default redirect URL.\n * > **Note** This method will throw an exception if you're using the bare workflow on native.\n *\n * @param path\n * @return\n *\n * @example\n * ```ts\n * const url = AuthSession.getRedirectUrl('redirect');\n *\n * // Managed: https://auth.expo.io/@your-username/your-app-slug/redirect\n * // Web: https://localhost:19006/redirect\n * ```\n *\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl({ urlPath: path });\n}\n\n// @needsAudit\n/**\n * Create a redirect url for the current platform and environment. You need to manually define the redirect that will be used in\n * a bare workflow React Native app, or an Expo standalone app, this is because it cannot be inferred automatically.\n * - **Web:** Generates a path based on the current `window.location`. For production web apps, you should hard code the URL as well.\n * - **Managed workflow:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses `auth.expo.io` as the base URL for the path. This only works in Expo Go and standalone environments.\n * - **Bare workflow:** Will fallback to using the `native` option for bare workflow React Native apps.\n *\n * @param options Additional options for configuring the path.\n * @return The `redirectUri` to use in an authentication request.\n *\n * @example\n * ```ts\n * const redirectUri = makeRedirectUri({\n *   scheme: 'my-scheme',\n *   path: 'redirect'\n * });\n * // Development Build: my-scheme://redirect\n * // Expo Go: exp://127.0.0.1:19000/--/redirect\n * // Web dev: https://localhost:19006/redirect\n * // Web prod: https://yourwebsite.com/redirect\n *\n * const redirectUri2 = makeRedirectUri({\n *   scheme: 'scheme2',\n *   preferLocalhost: true,\n *   isTripleSlashed: true,\n * });\n * // Development Build: scheme2:///\n * // Expo Go: exp://localhost:19000\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n *\n * const redirectUri3 = makeRedirectUri({\n *   useProxy: true,\n * });\n * // Development Build: https://auth.expo.io/@username/slug\n * // Expo Go: https://auth.expo.io/@username/slug\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n * ```\n */\nexport function makeRedirectUri({\n  native,\n  scheme,\n  isTripleSlashed,\n  queryParams,\n  path,\n  preferLocalhost,\n  useProxy,\n  projectNameForProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (\n    Platform.OS !== 'web' &&\n    native &&\n    [ExecutionEnvironment.Standalone, ExecutionEnvironment.Bare].includes(\n      Constants.executionEnvironment\n    )\n  ) {\n    // Should use the user-defined native scheme in standalone builds\n    return native;\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.createURL(path || '', {\n      isTripleSlashed,\n      scheme,\n      queryParams,\n    });\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl({ urlPath: path, projectNameForProxy });\n}\n\n// @needsAudit\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config A valid [`AuthRequestConfig`](#authrequestconfig) that specifies what provider to use.\n * @param issuerOrDiscovery A loaded [`DiscoveryDocument`](#discoverydocument) or issuer URL.\n * (Only `authorizationEndpoint` is required for requesting an authorization code).\n * @return Returns an instance of `AuthRequest` that can be used to prompt the user for authorization.\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n\n// Provider specific types\nexport { GoogleAuthRequestConfig } from './providers/Google';\nexport { FacebookAuthRequestConfig } from './providers/Facebook';\n"]},"metadata":{},"sourceType":"module"}